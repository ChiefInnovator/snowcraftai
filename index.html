<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snowcraft Reforged</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        body { margin: 0; background: #222; overflow: hidden; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: 'Arial', sans-serif; }
        #game-container { box-shadow: 0 0 30px rgba(0,0,0,0.8); border: 4px solid #fff; border-radius: 8px; }
    </style>
</head>
<body>

<div id="game-container"></div>

<script>
// --- CONFIGURATION ---
const LEVEL_CONFIG = [
    { level: 1, enemies: 3, fireInterval: 2000, errorMargin: 0.35 }, 
    { level: 2, enemies: 3, fireInterval: 1500, errorMargin: 0.25 },
    { level: 3, enemies: 4, fireInterval: 1200, errorMargin: 0.15 },
    { level: 4, enemies: 5, fireInterval: 900,  errorMargin: 0.08 },
    { level: 5, enemies: 6, fireInterval: 700,  errorMargin: 0.05 },
];

class MainScene extends Phaser.Scene {
    constructor() {
        super({ key: 'MainScene' });
    }

    preload() {
        // --- ASSET LOADING ---
        // Loading full atlas images - frames defined manually in create()
        this.load.image('red_team_atlas', 'assets/player.png');
        this.load.image('green_team_atlas', 'assets/enemy.png');
        this.load.image('snowball', 'assets/snowball.png');
        this.load.image('splash', 'assets/splash.png');
        this.load.image('sink', 'assets/sink.png');
        this.load.image('puddle', 'assets/puddle.png');
        this.load.image('playfield', 'assets/playField.png');
        
        // Audio
        this.load.audio('sfx_throw', 'assets/throw.mp3');
        this.load.audio('sfx_hit', 'assets/hit1.mp3');
        this.load.audio('sfx_step', 'assets/hit2.mp3');

        // Procedural Shadow - softer, wider for diagonal rotation
        this.make.graphics({x: 0, y: 0, add: false})
            .fillStyle(0x000000, 0.25) // Reduced alpha for softer look
            .fillEllipse(20, 10, 40, 20) // Wider ellipse
            .generateTexture('shadow', 40, 20);
    }

    create() {
        // 1. Environment
        let bg = this.add.graphics();
        bg.fillGradientStyle(0xddeeff, 0xddeeff, 0xffffff, 0xffffff, 1);
        bg.fillRect(0, 0, 600, 320);
        bg.setDepth(-10);

        // Add Playfield Overlay (if you have it)
        // If this image fails to load, the gradient above will show instead.
        if (this.textures.exists('playfield')) {
            let pf = this.add.image(300, 160, 'playfield');
            pf.setDisplaySize(600, 320);
            pf.setDepth(-5);
        }

        // 2. Define Frames & Animations
        // Red Team (Player) Frames
        const redTex = this.textures.get('red_team_atlas');
        redTex.add('idle_0', 0, 148, 19, 26, 34);
        redTex.add('walk_0', 0, 15, 19, 24, 34);
        redTex.add('walk_1', 0, 59, 18, 30, 35);
        redTex.add('throw_0', 0, 84, 99, 31, 35);
        redTex.add('throw_1', 0, 150, 98, 23, 36);

        // Green Team (Enemy) Frames
        const greenTex = this.textures.get('green_team_atlas');
        greenTex.add('idle_0', 0, 133, 18, 30, 36);
        greenTex.add('idle_1', 0, 186, 18, 27, 34);
        greenTex.add('throw_0', 0, 292, 23, 24, 31);
        greenTex.add('throw_1', 0, 332, 19, 34, 35);
        greenTex.add('throw_2', 0, 393, 20, 24, 34);

        // Animations
        this.anims.create({
            key: 'red_idle',
            frames: [{ key: 'red_team_atlas', frame: 'idle_0' }],
            frameRate: 1, repeat: -1
        });
        this.anims.create({
            key: 'red_walk',
            frames: [
                { key: 'red_team_atlas', frame: 'walk_0' },
                { key: 'red_team_atlas', frame: 'walk_1' }
            ],
            frameRate: 6, repeat: -1
        });
        this.anims.create({
            key: 'red_throw',
            frames: [
                { key: 'red_team_atlas', frame: 'throw_0' },
                { key: 'red_team_atlas', frame: 'throw_1' }
            ],
            frameRate: 10, repeat: 0
        });
        
        this.anims.create({
            key: 'green_idle',
            frames: [
                { key: 'green_team_atlas', frame: 'idle_0' },
                { key: 'green_team_atlas', frame: 'idle_1' }
            ],
            frameRate: 4, repeat: -1
        });
        this.anims.create({
            key: 'green_walk',
            frames: [
                { key: 'green_team_atlas', frame: 'idle_0' },
                { key: 'green_team_atlas', frame: 'idle_1' }
            ],
            frameRate: 8, repeat: -1 // Faster for walking
        });
        this.anims.create({
            key: 'green_throw',
            frames: [
                { key: 'green_team_atlas', frame: 'throw_0' },
                { key: 'green_team_atlas', frame: 'throw_1' },
                { key: 'green_team_atlas', frame: 'throw_2' }
            ],
            frameRate: 10, repeat: 0
        });

        // 3. Game Groups & State
        this.projectiles = this.add.group();
        this.redTeam = [];
        this.greenTeam = [];
        this.isCharging = false;
        this.chargeDirection = 1;
        this.chargePower = 0;
        this.maxPower = 100;
        this.chargeSpeed = 150; // Power units per second
        
        // 4. UI Elements
        this.powerBarBg = this.add.rectangle(0, 0, 52, 10, 0x000000).setOrigin(0, 0.5).setDepth(99);
        this.powerBar = this.add.rectangle(0, 0, 0, 8, 0x00ff00).setOrigin(0, 0.5).setDepth(100);
        this.levelText = this.add.text(300, 160, '', { fontSize: '60px', color: '#cc0000', fontStyle: 'bold', stroke: '#fff', strokeThickness: 6 }).setOrigin(0.5).setDepth(200).setVisible(false);

        // 5. Inputs
        this.input.mouse.disableContextMenu(); // Enable Right Click

        // LEFT CLICK: Select & Start Charging / Release to Throw
        this.input.on('pointerdown', (pointer) => {
            if (!this.isLevelActive) return;

            if (pointer.leftButtonDown()) {
                // If already charging, ignore new clicks
                if (this.isCharging) return;
                
                // Check if clicking on a player to select
                let clickedPlayer = this.getClosestActive(this.redTeam, pointer, 40);
                if (clickedPlayer) {
                    this.activePlayer = clickedPlayer;
                    this.isCharging = true;
                    this.chargePower = 0;
                    this.chargeDirection = 1;
                    this.targetX = pointer.x; // Store initial click position as target
                    this.targetY = pointer.y;
                    
                    // Visual Feedback
                    this.redTeam.forEach(k => k.bodySprite.setTint(0xffffff));
                    clickedPlayer.bodySprite.setTint(0xffff00); 
                } else if (this.activePlayer && this.activePlayer.isAlive) {
                    // Clicking elsewhere with selected player - start charging toward that point
                    this.isCharging = true;
                    this.chargePower = 0;
                    this.chargeDirection = 1;
                    this.targetX = pointer.x;
                    this.targetY = pointer.y;
                }
            } else if (pointer.rightButtonDown()) {
                // RIGHT CLICK: Move (cancel any charging)
                this.isCharging = false;
                if (this.activePlayer && this.activePlayer.isAlive) {
                    this.movePlayer(this.activePlayer, pointer.x, pointer.y);
                }
            }
        });

        // Track mouse movement while charging to update target
        this.input.on('pointermove', (pointer) => {
            if (this.isCharging && this.activePlayer) {
                this.targetX = pointer.x;
                this.targetY = pointer.y;
            }
        });

        this.input.on('pointerup', (pointer) => {
            if (this.isCharging && this.activePlayer && this.isLevelActive && pointer.leftButtonReleased()) {
                // Release to throw with current power
                if (this.chargePower > 5) {
                    this.throwSnowball(this.activePlayer, this.chargePower, this.targetX, this.targetY);
                }
                this.isCharging = false;
                this.activePlayer.bodySprite.setTint(0xffffff);
                this.activePlayer = null;
            }
        });

        this.startLevel(0);
    }

    startLevel(index) {
        this.currentLevelIndex = index;
        let config = LEVEL_CONFIG[index] || LEVEL_CONFIG[LEVEL_CONFIG.length - 1];
        this.currentConfig = config;
        
        // Is this the very first level?
        let isIntro = (index === 0);

        // Cleanup
        this.greenTeam.forEach(k => k.destroy());
        this.greenTeam = [];
        this.projectiles.clear(true, true);

        // --- SPAWN TEAMS ---
        // Destroy Red Team to re-animate them walking in for Level 1
        if (isIntro) {
            this.redTeam.forEach(k => k.destroy());
            this.redTeam = [];
            this.createTeam('player', this.redTeam, 3, true); // True = Walk In
        } else {
            // Normal Level Reset (Revive or Keep Position)
            if (this.redTeam.length === 0) {
                this.createTeam('player', this.redTeam, 3, false);
            } else {
                this.redTeam.forEach(kid => {
                    kid.isAlive = true;
                    kid.visible = true;
                    kid.alpha = 1;
                    kid.angle = 0;
                    kid.bodySprite.play('red_idle');
                    kid.bodySprite.setTint(0xffffff);
                });
            }
        }

        // Spawn Green Team (they always walk in on Level 1)
        this.createTeam('cpu', this.greenTeam, config.enemies, isIntro);

        // --- LEVEL TEXT LOGIC ---
        let message = isIntro ? "Season's Greetings" : 'LEVEL ' + (index + 1);
        
        this.levelText.setText(message);
        this.levelText.setStyle({ 
            fontSize: isIntro ? '40px' : '60px',
            fontFamily: isIntro ? 'Georgia, serif' : 'Arial, sans-serif'
        });
        
        this.levelText.setVisible(true);
        this.levelText.alpha = 0;
        this.levelText.y = 160;
        this.isLevelActive = false;

        // Fade In -> Hold -> Fade Out
        this.tweens.add({
            targets: this.levelText,
            alpha: 1,
            duration: 1000,
            hold: isIntro ? 2500 : 1500, // Longer hold for walk-in
            yoyo: true,
            onComplete: () => {
                this.isLevelActive = true;
                this.setupAITimer(config.fireInterval);
            }
        });
    }

    createTeam(type, teamArray, count, isIntro = false) {
        // COORDINATE SWAP (Match Original Game)
        // Green (CPU) = LEFT SIDE | Red (Player) = RIGHT SIDE
        const leftX = 100;
        const rightX = 500;
        
        // CPU (Green) on Left, Player (Red) on Right
        let finalX = (type === 'player') ? rightX : leftX;
        
        // --- DIAGONAL ENTRANCE LOGIC ---
        // Start from Top-Right (Red) or Top-Left (Green)
        let startX = (type === 'player') ? 650 : -50;
        let startY = -100; // Start above the screen

        // Y Slots (Mound positions)
        const ySlots = [96, 211, 296, 140, 246, 172];
        const textureKey = (type === 'player') ? 'red_team_atlas' : 'green_team_atlas';
        const prefix = (type === 'player') ? 'red' : 'green';

        for (let i = 0; i < count; i++) {
            let finalY = ySlots[i % ySlots.length];
            
            // Intro: Spawn at top corners. Gameplay: Spawn at mound.
            let spawnX = isIntro ? startX : finalX;
            let spawnY = isIntro ? startY : finalY;
            
            let kid = this.add.container(spawnX, spawnY);
            
            // Shadow setup - offset to bottom-right for diagonal lighting
            let shadow = this.add.image(12, 22, 'shadow');
            shadow.setRotation(0.5); // Rotate ~30 degrees to match diagonal light source
            shadow.setScale(0.8, 0.6); // Flatten it slightly
            shadow.setAlpha(0.25);
            kid.add(shadow);
            
            let sprite = this.add.sprite(0, 0, textureKey);
            
            // No flip needed - both sprites face their natural direction
            sprite.setFlipX(false);
            
            kid.add(sprite);
            kid.isAlive = true;
            kid.teamType = type;
            kid.bodySprite = sprite;
            kid.setSize(30, 50);

            teamArray.push(kid);

            // --- DIAGONAL WALK ANIMATION ---
            if (isIntro) {
                sprite.play(prefix + '_walk');
                
                this.tweens.add({
                    targets: kid,
                    x: finalX,       // Move to Mound X
                    y: finalY,       // Move to Mound Y (diagonal!)
                    duration: 2500 + (i * 200),
                    ease: 'Linear',
                    onComplete: () => {
                        sprite.play(prefix + '_idle');
                    }
                });
            } else {
                // Immediate spawn (Levels 2+)
                sprite.playAfterDelay(prefix + '_idle', Math.random() * 1000);
            }
        }
    }

    update(time, delta) {
        // Update power meter (oscillating charge)
        if (this.isCharging && this.activePlayer) {
            // Oscillate power up and down
            this.chargePower += this.chargeDirection * this.chargeSpeed * (delta / 1000);
            
            // Bounce at limits
            if (this.chargePower >= this.maxPower) {
                this.chargePower = this.maxPower;
                this.chargeDirection = -1;
            } else if (this.chargePower <= 0) {
                this.chargePower = 0;
                this.chargeDirection = 1;
            }
            
            // Show power bar above player
            this.powerBarBg.setVisible(true);
            this.powerBar.setVisible(true);
            this.powerBarBg.setPosition(this.activePlayer.x - 26, this.activePlayer.y - 40);
            this.powerBar.setPosition(this.activePlayer.x - 25, this.activePlayer.y - 40);
            this.powerBar.width = (this.chargePower / this.maxPower) * 50;
            
            // Color gradient: green -> yellow -> red
            if (this.chargePower < 33) {
                this.powerBar.fillColor = 0x00ff00; // Green
            } else if (this.chargePower < 66) {
                this.powerBar.fillColor = 0xffff00; // Yellow
            } else {
                this.powerBar.fillColor = 0xff0000; // Red
            }
        } else {
            this.powerBarBg.setVisible(false);
            this.powerBar.setVisible(false);
        }

        [...this.projectiles.getChildren()].forEach(ball => {
            ball.z += ball.zSpeed;
            ball.zSpeed -= 0.5;

            if (ball.z <= 0) {
                ball.z = 0;
                this.createSnowSplash(ball.x, ball.y);
                this.playRandomSound('sfx_step', 0.2);
                ball.destroy();
            } else {
                ball.x += ball.vx;
                ball.y += ball.vy;
                
                // 3D Visuals
                let scale = 1 + (ball.z / 300);
                ball.setScale(scale);
                
                // Shadow: diagonal offset to match player shadows (top-left light source)
                ball.shadow.setPosition(ball.x + 15, (ball.y + ball.z) + 15);
                ball.shadow.setRotation(0.5); // Match player shadow angle
                ball.shadow.setAlpha(0.6 - (ball.z / 100)); // Fade out as ball goes higher

                if (ball.z < 40 && ball.z > 5) {
                    let targetTeam = (ball.throwerTeam === 'player') ? this.greenTeam : this.redTeam;
                    targetTeam.forEach(enemy => {
                        if (enemy.isAlive && Phaser.Math.Distance.Between(ball.x, ball.y, enemy.x, enemy.y) < 30) {
                            this.handleHit(enemy, ball);
                        }
                    });
                }
            }
        });
    }

    throwSnowball(thrower, power, targetX, targetY) {
        // Power is 0-100 from the oscillating meter
        let scaledPower = 200 + (power * 6); // Range: 200-800
        
        let ball = this.add.image(thrower.x, thrower.y - 20, 'snowball');
        ball.shadow = this.add.image(thrower.x, thrower.y, 'shadow');
        ball.throwerTeam = thrower.teamType;
        
        ball.z = 35; 
        ball.zSpeed = 4 + (power / 20); // Range: 4-9
        
        // Aim toward target position
        let angle = Phaser.Math.Angle.Between(thrower.x, thrower.y, targetX, targetY);
        
        let speed = scaledPower / 40; // Range: 5-20
        ball.vx = Math.cos(angle) * speed;
        ball.vy = Math.sin(angle) * speed;

        this.projectiles.add(ball);

        let prefix = (thrower.teamType === 'player') ? 'red' : 'green';
        thrower.bodySprite.play(prefix + '_throw');
        thrower.bodySprite.once('animationcomplete', () => {
            if(thrower.isAlive) thrower.bodySprite.play(prefix + '_idle');
        });
        this.playRandomSound('sfx_throw', 0.8);
    }

    handleHit(kid, ball) {
        ball.shadow.destroy();
        ball.destroy();
        kid.isAlive = false;
        kid.bodySprite.stop();
        this.playRandomSound('sfx_hit', 1.0);
        this.cameras.main.shake(100, 0.005);
        
        // Classic Snowcraft hit animation: kid falls over and sinks into snow
        // 1. Show splash at impact point
        let splash = this.add.image(kid.x, kid.y + 10, 'splash').setDepth(kid.depth - 1);
        
        // 2. Kid falls over (rotate and lower)
        this.tweens.add({ 
            targets: kid, 
            angle: 90, 
            y: kid.y + 15,
            duration: 300,
            onComplete: () => {
                // 3. Transition splash to sink
                splash.setTexture('sink');
                
                // 4. Kid sinks down and fades
                this.tweens.add({
                    targets: kid,
                    alpha: 0,
                    scaleX: 0.5,
                    scaleY: 0.5,
                    duration: 600,
                    onComplete: () => {
                        kid.setVisible(false);
                        
                        // 5. Show puddle where they sank
                        splash.setTexture('puddle');
                        
                        // 6. Puddle fades slowly
                        this.tweens.add({
                            targets: splash,
                            alpha: 0,
                            duration: 2000,
                            delay: 1000,
                            onComplete: () => splash.destroy()
                        });
                    }
                });
            }
        });
        
        this.checkWinCondition();
    }

    checkWinCondition() {
        let greenAlive = this.greenTeam.filter(k => k.isAlive).length;
        let redAlive = this.redTeam.filter(k => k.isAlive).length;
        if (greenAlive === 0) {
            this.isLevelActive = false;
            if (this.aiTimer) this.aiTimer.remove();
            this.time.delayedCall(2000, () => this.startLevel(this.currentLevelIndex + 1));
        } else if (redAlive === 0) {
            this.isLevelActive = false;
            if (this.aiTimer) this.aiTimer.remove();
            this.levelText.setText("GAME OVER");
            this.levelText.setVisible(true);
            this.input.once('pointerdown', () => location.reload());
        }
    }

    setupAITimer(interval) {
        if (this.aiTimer) this.aiTimer.remove();
        this.aiTimer = this.time.addEvent({ delay: interval, callback: this.cpuThink, callbackScope: this, loop: true });
    }

    cpuThink() {
        if (!this.isLevelActive) return;
        let candidates = this.greenTeam.filter(k => k.isAlive);
        if (candidates.length === 0) return;
        let thrower = candidates[Phaser.Math.Between(0, candidates.length - 1)];
        let targets = this.redTeam.filter(k => k.isAlive);
        if (targets.length === 0) return;
        let target = targets[Phaser.Math.Between(0, targets.length - 1)];

        // Calculate aim with some error
        let error = Phaser.Math.FloatBetween(-this.currentConfig.errorMargin, this.currentConfig.errorMargin);
        let targetX = target.x + (error * 100);
        let targetY = target.y + (error * 50);

        // Random power between 50-90
        let power = Phaser.Math.Between(50, 90);
        
        this.throwSnowball(thrower, power, targetX, targetY);
    }

    createSnowSplash(x, y) {
        // Play splash animation sequence: Splash -> Sink -> Puddle
        let splash = this.add.image(x, y, 'splash').setDepth(50);
        
        this.time.delayedCall(120, () => {
            splash.setTexture('sink');
            this.time.delayedCall(120, () => {
                splash.setTexture('puddle');
                this.tweens.add({
                    targets: splash,
                    alpha: 0,
                    duration: 1000,
                    delay: 500,
                    onComplete: () => splash.destroy()
                });
            });
        });
    }

    playRandomSound(key, volume = 1) {
        if (this.sound.get(key)) {
             let detune = Phaser.Math.Between(-200, 200); 
             this.sound.play(key, { detune: detune, volume: volume });
        }
    }
    
    movePlayer(kid, x, y) {
        x = Phaser.Math.Clamp(x, 40, 260); // Keep on left side
        y = Phaser.Math.Clamp(y, 70, 300);

        this.createSnowSplash(x, y); // Visual feedback
        this.playRandomSound('sfx_step', 0.2); // Sound feedback

        this.tweens.add({
            targets: kid,
            x: x,
            y: y,
            duration: Phaser.Math.Distance.Between(kid.x, kid.y, x, y) * 5,
            onStart: () => { if(kid.bodySprite.anims.exists('red_walk')) kid.bodySprite.play('red_walk'); },
            onComplete: () => { if(kid.isAlive) kid.bodySprite.play('red_idle'); }
        });
    }

    getClosestActive(team, pointer, maxDist = 1000) {
        let closest = null;
        let minDist = maxDist;
        team.forEach(kid => {
            if (!kid.isAlive) return;
            let d = Phaser.Math.Distance.Between(pointer.x, pointer.y, kid.x, kid.y);
            if (d < minDist) {
                minDist = d;
                closest = kid;
            }
        });
        return closest;
    }
}

const config = {
    type: Phaser.AUTO,
    width: 600,
    height: 320,
    parent: 'game-container',
    backgroundColor: '#333',
    physics: { default: 'arcade' },
    scene: MainScene
};

const game = new Phaser.Game(config);
</script>
</body>
</html>