<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snowcraft Reforged</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        body { margin: 0; background: #222; overflow: hidden; display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100vh; font-family: 'Arial', sans-serif; }
        #game-container { box-shadow: 0 0 30px rgba(0,0,0,0.8); border: 4px solid #fff; border-radius: 8px; line-height: 0; }
        #game-container canvas { display: block; }
        #options-bar { margin-bottom: 10px; color: #fff; font-size: 14px; display: flex; gap: 20px; }
        #options-bar select { padding: 5px 10px; font-size: 14px; border-radius: 4px; cursor: pointer; }
        #instructions { margin-top: 15px; color: #ccc; font-size: 14px; text-align: center; line-height: 1.5; max-width: 600px; }
        #instructions strong { color: #fff; }
    </style>
</head>
<body>

<div id="options-bar">
    <div>
        Difficulty: 
        <select id="difficulty-select" onchange="changeDifficulty()">
            <option value="1">Easy</option>
            <option value="2" selected>Normal</option>
            <option value="3">Hard</option>
        </select>
    </div>
    <div>
        Display Size: 
        <select id="scale-select" onchange="changeScale()">
            <option value="1">600 x 320 (1x)</option>
            <option value="1.5">900 x 480 (1.5x)</option>
            <option value="2">1200 x 640 (2x)</option>
            <option value="2.5">1500 x 800 (2.5x)</option>
            <option value="3">1800 x 960 (3x)</option>
        </select>
    </div>
</div>
<div id="game-container"></div>

<div id="instructions">
    <strong>Controls:</strong> Click & Hold a red player to charge power. Release to throw.<br>
    Defeat the Green Team to advance!
</div>

<script>
// --- CONFIGURATION ---
const DEBUG_MODE = false; // Set to false to hide coordinate labels
const START_LEVEL = 5; // Level to start on (1-5) for testing. Default is 1.
let GAME_SCALE = 1; // Set to 2 for 1200x640, or any multiplier (default 1 = 600x320)
let GAME_DIFFICULTY = 2; // 1=Easy, 2=Normal, 3=Hard
let game = null;

function changeDifficulty() {
    const newDifficulty = parseInt(document.getElementById('difficulty-select').value);
    if (newDifficulty !== GAME_DIFFICULTY) {
        GAME_DIFFICULTY = newDifficulty;
        if (game) {
            game.destroy(true);
        }
        game = new Phaser.Game(getConfig());
    }
}

function changeScale() {
    const newScale = parseFloat(document.getElementById('scale-select').value);
    if (newScale !== GAME_SCALE) {
        GAME_SCALE = newScale;
        if (game) {
            game.destroy(true);
        }
        game = new Phaser.Game(getConfig());
    }
}

function getConfig() {
    return {
        type: Phaser.AUTO,
        width: 600,
        height: 320,
        parent: 'game-container',
        backgroundColor: '#ffffff',
        pixelArt: true,
        scale: {
            zoom: GAME_SCALE
        },
        physics: { default: 'arcade' },
        scene: MainScene
    };
}

const LEVEL_CONFIG = [
    { level: 1, enemies: 3, errorMargin: 0.35 }, 
    { level: 2, enemies: 5, errorMargin: 0.25 },
    { level: 3, enemies: 7, errorMargin: 0.15 },
    { level: 4, enemies: 9, errorMargin: 0.08 },
    { level: 5, enemies: 11, errorMargin: 0.05 },
];

class MainScene extends Phaser.Scene {
    constructor() {
        super({ key: 'MainScene' });
    }

    preload() {
        // --- ASSET LOADING ---
        this.load.image('red_team_atlas', 'assets/player.png');
        this.load.image('green_team_atlas', 'assets/enemy.png');
        this.load.image('snowball', 'assets/snowball.png');
        this.load.image('splash', 'assets/splash.png');
        this.load.image('sink', 'assets/sink.png');
        this.load.image('puddle', 'assets/puddle.png');
        this.load.image('playfield', 'assets/playField.png');
        this.load.image('shadow', 'assets/shadow.png');
        this.load.image('snowball_shadow', 'assets/snowball_shadow.png');
        this.load.image('hand', 'assets/smallHand.png');
        
        // Audio
        this.load.audio('sfx_throw', 'assets/throw.mp3');
        this.load.audio('sfx_hit1', 'assets/hit1.mp3');
        this.load.audio('sfx_hit2', 'assets/hit2.mp3');
        this.load.audio('sfx_hit3', 'assets/hit3.mp3');
        this.load.audio('sfx_deathHit', 'assets/deathHit.mp3');
        this.load.audio('sfx_intro', 'assets/intro.mp3');
        this.load.audio('sfx_introAlt', 'assets/introAlt.mp3');
        this.load.audio('music', 'assets/musicAlt.mp3');
    }

    create() {
        // 1. Environment
        let bg = this.add.graphics();
        bg.fillGradientStyle(0xddeeff, 0xddeeff, 0xffffff, 0xffffff, 1);
        bg.fillRect(0, 0, 600, 320);
        bg.setDepth(-10);

        // Debug diagonal line from bottom-left to top-right
        if (DEBUG_MODE) {
            let debugLine = this.add.graphics();
            debugLine.lineStyle(2, 0xff0000, 1);
            debugLine.lineBetween(0, 320, 600, 0);
            debugLine.setDepth(100);
        }

        // Add Playfield Overlay
        if (this.textures.exists('playfield')) {
            let pf = this.add.image(300, 160, 'playfield');
            pf.setDisplaySize(600, 320);
            pf.setDepth(-5);
        }

        // 2. Define Frames & Animations
        // Red Team
        const redTex = this.textures.get('red_team_atlas');
        redTex.add('idle_0', 0, 148, 19, 26, 34);
        redTex.add('walking', 0, 15, 19, 24, 34);
        redTex.add('walkingAlt', 0, 59, 18, 30, 35);
        redTex.add('throw_0', 0, 84, 99, 31, 35);
        redTex.add('throw_1', 0, 150, 98, 23, 36);
        redTex.add('hit_0', 0, 199, 24, 35, 30);
        redTex.add('hit_1', 0, 258, 11, 32, 43);
        redTex.add('hit_2', 0, 312, 10, 36, 44);
        redTex.add('hit_3', 0, 368, 13, 35, 40);
        redTex.add('death_0', 0, 208, 109, 71, 32);
        redTex.add('hardDeath', 0, 290, 101, 68, 48);
        redTex.add('wipedOut', 0, 376, 98, 51, 53);

        // Green Team
        const greenTex = this.textures.get('green_team_atlas');
        greenTex.add('idle_0', 0, 133, 18, 30, 36);
        greenTex.add('idle_1', 0, 186, 18, 27, 34);
        greenTex.add('walking', 0, 133, 18, 30, 36);
        greenTex.add('walkingAlt', 0, 186, 18, 27, 34);
        greenTex.add('throw_0', 0, 292, 23, 24, 31);
        greenTex.add('throw_1', 0, 332, 19, 34, 35);
        greenTex.add('throw_2', 0, 393, 20, 24, 34);
        greenTex.add('hit_0', 0, 26, 75, 25, 35);
        greenTex.add('guard', 0, 74, 75, 29, 35);
        greenTex.add('brushOff', 0, 124, 75, 29, 35);
        greenTex.add('stunned', 0, 170, 76, 35, 34);
        greenTex.add('death_0', 0, 44, 145, 66, 42);
        greenTex.add('hardDeath', 0, 137, 142, 54, 46);
        greenTex.add('wipedOut', 0, 220, 145, 69, 42);
        greenTex.add('minorDeath', 0, 317, 145, 49, 38);
        greenTex.add('victory_0', 0, 244, 78, 42, 35);
        greenTex.add('victory_1', 0, 312, 77, 40, 37);
        greenTex.add('victory_2', 0, 380, 76, 42, 37);

        // Animations
        this.anims.create({ key: 'red_idle', frames: [{ key: 'red_team_atlas', frame: 'idle_0' }], frameRate: 1, repeat: -1 });
        this.anims.create({ key: 'red_walk', frames: [{ key: 'red_team_atlas', frame: 'walking' }, { key: 'red_team_atlas', frame: 'walkingAlt' }], frameRate: 5, repeat: -1 });
        this.anims.create({ key: 'red_throw', frames: [{ key: 'red_team_atlas', frame: 'throw_0' }, { key: 'red_team_atlas', frame: 'throw_1' }], frameRate: 10, repeat: 0 });
        
        this.anims.create({ key: 'green_idle', frames: [{ key: 'green_team_atlas', frame: 'idle_0' }, { key: 'green_team_atlas', frame: 'idle_1' }], frameRate: 4, repeat: -1 });
        this.anims.create({ key: 'green_walk', frames: [{ key: 'green_team_atlas', frame: 'walking' }, { key: 'green_team_atlas', frame: 'walkingAlt' }], frameRate: 5, repeat: -1 });
        this.anims.create({ key: 'green_throw', frames: [{ key: 'green_team_atlas', frame: 'throw_0' }, { key: 'green_team_atlas', frame: 'throw_1' }, { key: 'green_team_atlas', frame: 'throw_2' }], frameRate: 10, repeat: 0 });

        this.anims.create({ key: 'red_death', frames: [{ key: 'red_team_atlas', frame: 'death_0' }], frameRate: 1, repeat: 0 });
        this.anims.create({ 
            key: 'green_victory', 
            frames: [{ key: 'green_team_atlas', frame: 'victory_0' }, { key: 'green_team_atlas', frame: 'victory_1' }, { key: 'green_team_atlas', frame: 'victory_2' }], 
            frameRate: 4, repeat: -1 
        });

        // 3. Game Groups & State
        this.shadowGroup = this.add.group(); // Shadows drawn first (lowest depth)
        this.projectiles = this.add.group();
        this.redTeam = [];
        this.greenTeam = [];
        this.isLevelActive = false; // Must be false until players finish walking
        this.isDragging = false;
        this.dragStartX = 0;
        this.dragStartY = 0;
        this.dragOriginX = 0;
        this.dragOriginY = 0;
        this.activeStrength = 1;
        this.maxStrength = 100;
        
        // 4. UI Elements
        this.strengthText = this.add.text(0, 0, '', { fontSize: '8px', color: '#ff0000', fontFamily: 'Arial' }).setDepth(100).setVisible(false);
        this.levelText = this.add.text(300, 160, '', { fontSize: '60px', color: '#cc0000', fontStyle: 'bold', stroke: '#fff', strokeThickness: 6 }).setOrigin(0.5).setDepth(200).setVisible(false);

        // Selection Circle (dashed blue circle like original)
        this.selectionCircle = this.add.graphics();
        this.selectionCircle.setDepth(-1);  // Draw behind player
        this.selectionCircle.setVisible(false);
        
        // Power Meter Bars (green bars like original)
        this.powerMeterBars = [];
        this.powerMeterContainer = this.add.container(0, 0).setDepth(100).setVisible(false);
        const barWidth = 12;
        const barHeight = 4;
        const barGap = 2;
        const numBars = 8;
        for (let i = 0; i < numBars; i++) {
            let bar = this.add.graphics();
            bar.fillStyle(0x00ff00, 1); // Green color
            bar.fillRect(0, 0, barWidth, barHeight);
            bar.lineStyle(1, 0x006600, 1); // Dark green border
            bar.strokeRect(0, 0, barWidth, barHeight);
            bar.y = -i * (barHeight + barGap);
            this.powerMeterContainer.add(bar);
            this.powerMeterBars.push(bar);
        }

        // Custom Cursor
        this.input.setDefaultCursor('url(assets/smallHand.png), pointer');
        
        // Music
        this.music = this.sound.add('music', { loop: true, volume: 0.3 });
        
        // 5. Inputs
        this.input.mouse.disableContextMenu(); 
        this.hoveredPlayer = null;

        // Hover detection - show selection circle when mouse is over a player
        this.input.on('pointermove', (pointer) => {
            // No selection allowed until level is active (players finished walking)
            if (!this.isLevelActive) {
                if (this.hoveredPlayer) {
                    this.hideSelectionUI();
                    this.hoveredPlayer = null;
                }
                return;
            }
            
            // If dragging, move the player and update UI
            if (this.isDragging && this.activePlayer && this.activePlayer.isAlive) {
                let newX = Math.round(pointer.x);
                let newY = Math.round(pointer.y);
                
                // Enforce diagonal boundary - red team must stay below the line
                // Line goes from (0, 320) to (600, 0), equation: y = 320 - (x * 320/600)
                let boundaryY = 320 - (newX * 320 / 600);
                if (newY < boundaryY) {
                    newY = Math.round(boundaryY);
                }
                
                // Keep within game bounds
                newX = Math.max(0, Math.min(600, newX));
                newY = Math.max(0, Math.min(320, newY));
                
                this.activePlayer.x = newX;
                this.activePlayer.y = newY;
                this.activePlayer.bodySprite.setFrame('throw_0');
                this.updateSelectionUI(this.activePlayer);
                return;
            }
            
            // Check if hovering over a player
            let hovered = this.getClosestActive(this.redTeam, pointer, 40);
            
            if (hovered && hovered.isAlive) {
                // Show selection on new hovered player
                if (this.hoveredPlayer !== hovered) {
                    this.hoveredPlayer = hovered;
                    this.showSelectionUI(hovered);
                } else {
                    // Update position in case player moved
                    this.updateSelectionUI(hovered);
                }
            } else {
                // Not hovering over any player - hide selection
                if (this.hoveredPlayer) {
                    this.hideSelectionUI();
                    this.hoveredPlayer = null;
                }
            }
        });

        // Mousedown - start power meter if hovering over a player
        this.input.on('pointerdown', (pointer) => {
            if (!this.isLevelActive) return;
            if (this.isDragging) return;

            if (pointer.leftButtonDown() && this.hoveredPlayer && this.hoveredPlayer.isAlive) {
                this.activePlayer = this.hoveredPlayer;
                this.isDragging = true;
                this.activeStrength = 1;
                // Store original position
                this.dragOriginX = this.activePlayer.x;
                this.dragOriginY = this.activePlayer.y;
                this.dragStartX = pointer.x;
                this.dragStartY = pointer.y;
                // Show cocked sprite
                this.activePlayer.bodySprite.setFrame('throw_0');
                // Show power meter (selection circle already visible from hover)
                this.showPowerMeter(this.activePlayer);
                // Start increasing strength (power meter)
                this.increaseStrength();
            }
        });

        this.input.on('pointerup', (pointer) => {
            if (this.isDragging && this.activePlayer && this.isLevelActive && pointer.leftButtonReleased()) {
                // Original behavior: player stays where dragged, doesn't snap back
                // Throw from current position with accumulated strength
                this.throwSnowball(this.activePlayer, this.activeStrength, 0, 0);
                
                // Reset to idle animation (player stays at current position) - only if alive
                if (this.activePlayer.isAlive) this.activePlayer.bodySprite.play('red_idle');
                
                // Hide power meter only (selection circle stays if still hovering)
                this.hidePowerMeter();
                
                this.isDragging = false;
                this.activeStrength = 1;
                this.strengthText.setVisible(false);
                
                // Update hovered player to current position
                this.hoveredPlayer = this.activePlayer;
                this.activePlayer = null;
            }
        });
        
        // Handle pointer leaving game area - cancel drag without throwing
        this.input.on('pointerupoutside', (pointer) => {
            if (this.isDragging && this.activePlayer) {
                if (this.activePlayer.isAlive) this.activePlayer.bodySprite.play('red_idle');
                this.hidePowerMeter();
                this.hideSelectionUI();
                this.isDragging = false;
                this.activeStrength = 1;
                this.strengthText.setVisible(false);
                this.hoveredPlayer = null;
                this.activePlayer = null;
            }
        });

        this.startLevel(START_LEVEL - 1);
    }

    startLevel(index) {
        this.currentLevelIndex = index;
        let config = LEVEL_CONFIG[index] || LEVEL_CONFIG[LEVEL_CONFIG.length - 1];
        this.currentConfig = config;
        
        let isIntro = (index === 0);
        
        if (isIntro) {
            this.sound.play('sfx_intro', { volume: 0.6 });
            if (!this.music.isPlaying) {
                this.music.play();
            }
        }

        this.greenTeam.forEach(k => { if (k.shadow) k.shadow.destroy(); k.destroy(); });
        this.greenTeam = [];
        
        // Clean up projectile shadows before clearing projectiles
        this.projectiles.children.each(ball => {
            if (ball.shadow) ball.shadow.destroy();
        });
        this.projectiles.clear(true, true);
        
        // Reset state BEFORE creating teams (so walkingCount increments work)
        this.isLevelActive = false;
        this.walkingCount = 0;
        this.textFadeComplete = false;

        if (isIntro) {
            this.redTeam.forEach(k => { if (k.shadow) k.shadow.destroy(); k.destroy(); });
            this.redTeam = [];
            this.createTeam('player', this.redTeam, 3, true); 
        } else {
            // For subsequent levels, red team walks in again
            this.redTeam.forEach(k => { if (k.shadow) k.shadow.destroy(); k.destroy(); });
            this.redTeam = [];
            this.createTeam('player', this.redTeam, 3, true);
        }

        // Green team always walks in from off-screen
        this.createTeam('cpu', this.greenTeam, config.enemies, true);

        let message = isIntro ? "Season's Greetings" : 'LEVEL ' + (index + 1);
        
        this.levelText.setText(message);
        this.levelText.setStyle({ 
            fontSize: isIntro ? '40px' : '60px',
            fontFamily: isIntro ? 'Georgia, serif' : 'Arial, sans-serif'
        });
        
        this.levelText.setVisible(true);
        this.levelText.alpha = 0;
        this.levelText.y = 160;

        this.tweens.add({
            targets: this.levelText,
            alpha: 1,
            duration: 1000,
            hold: isIntro ? 2500 : 1500, 
            yoyo: true,
            onComplete: () => {
                this.textFadeComplete = true;
                this.checkLevelReady();
            }
        });
    }

    checkLevelReady() {
        // Only activate level when text has faded AND all walking is complete
        // Guard against being called multiple times
        if (this.isLevelActive) return;
        
        if (this.textFadeComplete && this.walkingCount === 0) {
            this.isLevelActive = true;
            // Start enemy movement - each enemy picks a random destination
            this.greenTeam.forEach(enemy => {
                if (enemy.isAlive) {
                    this.calcEnemyPosition(enemy);
                    this.startEnemyMovement(enemy);
                }
            });
        }
    }

    createTeam(type, teamArray, count, isIntro = false) {
        const textureKey = (type === 'player') ? 'red_team_atlas' : 'green_team_atlas';
        const prefix = (type === 'player') ? 'red' : 'green';

        // Fixed positions matching original game (scaled to 600x320)
        const playerPositions = [
            { x: 500, y: 180 },  // Top-right red
            { x: 360, y: 265 },  // Bottom-left red  
            { x: 470, y: 275 },  // Bottom-middle red
            { x: 500, y: 270 },  // Right-middle red
            { x: 450, y: 275 },
            { x: 420, y: 300 }
        ];
        const enemyPositions = [
            { x: 95, y: 35 },    // Top-left green
            { x: 200, y: 30 },   // Top-right green
            { x: 70, y: 105 },   // Bottom-left green
            { x: 140, y: 70 },   // Extra positions if needed
            { x: 160, y: 120 },
            { x: 100, y: 90 }
        ];

        for (let i = 0; i < count; i++) {
            // Use fixed positions from original game
            let finalPos = (type === 'player') 
                ? playerPositions[i % playerPositions.length]
                : enemyPositions[i % enemyPositions.length];
            let finalX = finalPos.x;
            let finalY = finalPos.y;
            
            // --- DIAGONAL WALK-IN LOGIC ---
            let spawnX, spawnY;
            // Use a significant offset (e.g., 250px) to ensure they start well off-screen
            // and walk a clear diagonal path roughly 45 degrees.
            let offset = 250; 

            if (isIntro) {
                if (type === 'player') {
                    // Red Team (Right Side)
                    // Enters from Bottom-Right -> Walks Up-Left
                    spawnX = finalX + offset; 
                    spawnY = finalY + offset; 
                } else {
                    // Green Team (Left Side)
                    // Enters from Top-Left -> Walks Down-Right
                    spawnX = finalX - offset; 
                    spawnY = finalY - offset; 
                }
            } else {
                spawnX = finalX;
                spawnY = finalY;
            }
            
            let kid = this.add.container(spawnX, spawnY);
            
            // Shadow positioned for isometric view (added to global shadow group)
            let shadow = this.add.image(spawnX + 20, spawnY, 'shadow');
            shadow.setScale(1.2);
            shadow.setAlpha(0.6);
            shadow.setDepth(-5); // Ensure shadows are behind players
            this.shadowGroup.add(shadow);
            
            let sprite = this.add.sprite(0, 0, textureKey);
            sprite.setFlipX(false); // Assumes atlases are correctly oriented (Red=Left, Green=Right)
            
            kid.add(sprite);
            kid.isAlive = true;
            kid.teamType = type;
            kid.bodySprite = sprite;
            kid.shadow = shadow; // Reference to update position
            // Health based on difficulty: Easy=1, Normal=3, Hard=4 for enemies
            kid.health = (type === 'player') ? 3 : (GAME_DIFFICULTY === 1 ? 1 : GAME_DIFFICULTY === 2 ? 3 : 4);
            kid.isStunned = false;  // Prevents taking damage while in hit animation
            kid.setSize(30, 50);

            // Debug label showing coordinates
            if (DEBUG_MODE) {
                kid.debugLabel = this.add.text(0, -45, '', { 
                    fontSize: '10px', 
                    color: '#000000', 
                    backgroundColor: '#ffffff',
                    padding: { x: 2, y: 1 }
                }).setOrigin(0.5).setDepth(1000);
            }

            teamArray.push(kid);

            if (isIntro) {
                const walkingDistance = 3; 
                
                kid.walkFrame = 0;
                kid.isWalking = true;  // Animation toggle
                kid.isWalkingOntoField = true;  // Track if still entering field
                kid.finalX = finalX;
                kid.finalY = finalY;
                this.walkingCount++;
                
                sprite.setFrame('walking');
                
                kid.walkTimer = this.time.addEvent({
                    delay: 83, 
                    callback: () => {
                        let dx = kid.finalX - kid.x;
                        let dy = kid.finalY - kid.y;
                        
                        // Check arrival
                        if (Math.abs(dx) <= walkingDistance && Math.abs(dy) <= walkingDistance) {
                            kid.x = kid.finalX;
                            kid.y = kid.finalY;
                            if (kid.shadow) kid.shadow.setPosition(kid.x + 20, kid.y);
                            kid.isWalkingOntoField = false;  // Player has arrived on field
                            sprite.play(prefix + '_idle'); 
                            kid.walkTimer.remove();
                            this.walkingCount--;
                            this.checkLevelReady();
                            return;
                        }
                        
                        // Move diagonally
                        if (Math.abs(dx) > 0) {
                            kid.x += (dx > 0) ? walkingDistance : -walkingDistance;
                        }
                        if (Math.abs(dy) > 0) {
                            kid.y += (dy > 0) ? walkingDistance : -walkingDistance;
                        }
                        
                        if (kid.shadow) kid.shadow.setPosition(kid.x + 20, kid.y);
                        
                        // Toggle animation
                        kid.isWalking = !kid.isWalking;
                        sprite.setFrame(kid.isWalking ? 'walking' : 'walkingAlt');
                    },
                    loop: true
                });
            } else {
                sprite.playAfterDelay(prefix + '_idle', Math.random() * 1000);
            }
        }
    }

    // Increase strength while dragging - exponential acceleration
    increaseStrength() {
        if (this.isDragging && this.activeStrength < this.maxStrength) {
            // Exponential acceleration: delay decreases exponentially as strength increases
            // Formula: delay = baseDelay * e^(-k * strength)
            // This creates smooth exponential speedup
            let baseDelay = 40;  // Base delay in ms (Faster start)
            let k = 0.04; // Acceleration ramp (Faster acceleration)
            let delay = Math.max(5, Math.floor(baseDelay * Math.exp(-k * this.activeStrength)));
            
            this.activeStrength++;
            this.time.delayedCall(delay, () => this.increaseStrength());
        }
    }

    update(time, delta) {
        // Update power meter while dragging
        if (this.isDragging && this.activePlayer) {
            this.updatePowerMeter();
            // Update selection UI position to follow player
            this.updateSelectionUI(this.activePlayer);
        }

        // Update debug labels
        if (DEBUG_MODE) {
            [...this.redTeam, ...this.greenTeam].forEach(kid => {
                if (kid.debugLabel) {
                    // Position above player, or below if near top of screen
                    let labelY = (kid.y - 45 < 10) ? kid.y + 35 : kid.y - 45;
                    kid.debugLabel.setPosition(kid.x, labelY);
                    kid.debugLabel.setText(`${Math.round(kid.x)}, ${Math.round(kid.y)}`);
                    kid.debugLabel.setVisible(kid.isAlive);
                }
            });
        }

        [...this.projectiles.getChildren()].forEach(ball => {
            // Bezier curve trajectory (like original)
            if (ball.position !== undefined && ball.position < 1.0) {
                // Speed based on strength - higher power = slightly faster ball
                // Minimum speed of 0.012, scales up with strength (max ~0.018 at full power)
                let buffer = 0.012 + (ball.strength / 100) * 0.006;
                ball.position = (ball.position + buffer);
                
                if (ball.position >= 1.0) {
                    // Snowball landed
                    this.createSnowSplash(ball.x, ball.y);
                    if (ball.shadow) ball.shadow.destroy();
                    ball.destroy();
                    return;
                }
                
                // Quadratic Bezier calculation
                let t = ball.position;
                let iT = 1 - t;
                ball.x = Math.round(iT * iT * ball.startX + 2 * iT * t * ball.cpX + t * t * ball.endX);
                ball.y = Math.round(iT * iT * ball.startY + 2 * iT * t * ball.cpY + t * t * ball.endY);
                
                // Shadow follows ground position
                let groundY = (((ball.x - ball.startX) / (ball.endX - ball.startX) * (ball.endY - ball.startY)) + ball.startY);
                if (ball.shadow) {
                    ball.shadow.setPosition(ball.x, groundY);
                }
                
                // Check if out of bounds
                if (ball.x < 0 || ball.y < 0 || ball.x > 600 || ball.y > 320) {
                    if (ball.shadow) ball.shadow.destroy();
                    ball.destroy();
                    return;
                }
                
                // Hit detection during arc
                let targetTeam = (ball.throwerTeam === 'player') ? this.greenTeam : this.redTeam;
                targetTeam.forEach(enemy => {
                    if (enemy.isAlive && !enemy.isStunned &&
                        ball.x > enemy.x - 10 &&
                        ball.x < enemy.x + 30 &&
                        ball.y > enemy.y - 10 &&
                        ball.y < enemy.y + 50) {
                        this.handleHit(enemy, ball);
                    }
                });
            } else if (ball.zSpeed !== undefined) {
                // Fallback for old-style physics (CPU throws)
                ball.z += ball.zSpeed;
                ball.zSpeed -= 0.5;

                if (ball.z <= 0) {
                    ball.z = 0;
                    this.createSnowSplash(ball.x, ball.y);
                    if (ball.shadow) ball.shadow.destroy();
                    ball.destroy();
                } else {
                    ball.x += ball.vx;
                    ball.y += ball.vy;
                    
                    let scale = 1 + (ball.z / 300);
                    ball.setScale(scale);
                    
                    ball.shadow.setPosition(ball.x, ball.y + ball.z);
                    ball.shadow.setAlpha(Math.max(0.1, 0.6 - (ball.z / 100))); 

                    if (ball.z < 40 && ball.z > 5) {
                        let targetTeam = (ball.throwerTeam === 'player') ? this.greenTeam : this.redTeam;
                        targetTeam.forEach(enemy => {
                            if (enemy.isAlive && !enemy.isStunned && Phaser.Math.Distance.Between(ball.x, ball.y, enemy.x, enemy.y) < 30) {
                                this.handleHit(enemy, ball);
                            }
                        });
                    }
                }
            }
        });
    }

    throwSnowball(thrower, strength, targetX, targetY) {
        // Calculate distance based on strength (like original: baselineSnowballDistance * strength)
        let baselineDistance = 5;
        let distance = baselineDistance * strength;
        
        let ball = this.add.image(thrower.x + 5, thrower.y, 'snowball');
        ball.shadow = this.add.image(thrower.x + 5, thrower.y, 'snowball_shadow').setDepth(-5);
        this.shadowGroup.add(ball.shadow);
        ball.shadow.setAlpha(0.6);
        ball.throwerTeam = thrower.teamType;
        
        // Arc trajectory parameters
        ball.startX = thrower.x + 5;
        ball.startY = thrower.y;
        ball.strength = strength;
        ball.distance = distance;
        ball.position = 0.0;
        
        let angle = Phaser.Math.Angle.Between(thrower.x, thrower.y, targetX, targetY);
        
        // Calculate end point based on angle and distance
        // Isometric view: Y movement is ~half of X movement
        let arcHeight = Math.min(strength * 0.3, 30);
        let yDistance = distance * 0.5;  // Isometric ratio
        
        if (thrower.teamType === 'player') {
            // Player throws toward upper-left (toward enemies)
            ball.endX = ball.startX - distance;
            ball.endY = ball.startY - yDistance + 15;
            ball.cpX = ball.startX - (distance * 0.6);
            ball.cpY = ball.startY - (yDistance * 0.6) - arcHeight;
        } else {
            // Enemy throws toward player (right/down)
            ball.endX = ball.startX + distance;
            ball.endY = ball.startY + yDistance + 15;
            ball.cpX = ball.startX + (distance * 0.6);
            ball.cpY = ball.startY + (yDistance * 0.6) - arcHeight;
        }
        
        // For shadow tracking
        ball.z = 0;
        ball.zSpeed = 0;

        this.projectiles.add(ball);

        let prefix = (thrower.teamType === 'player') ? 'red' : 'green';
        // Show throwing frame
        thrower.bodySprite.setFrame('throw_1');
        this.time.delayedCall(100, () => {
            if(thrower.isAlive) thrower.bodySprite.play(prefix + '_idle');
        });
        this.playRandomSound('sfx_throw', 0.8);
    }

    handleHit(kid, ball) {
        // Ignore hits if already stunned or dead
        if (kid.isStunned || !kid.isAlive) return;
        
        ball.shadow.destroy();
        ball.destroy();
        
        kid.health--;
        kid.isStunned = true;  // Prevent multiple hits during animation
        
        this.playRandomSound('sfx_hit', 1.0);
        this.cameras.main.shake(100, 0.005);
        
        let prefix = (kid.teamType === 'player') ? 'red' : 'green';
        
        if (kid.health <= 0) {
            // Death - final hit (just show normalDeath frame like original)
            kid.isAlive = false;
            this.sound.play('sfx_deathHit', { volume: 0.8 });
            
            // Stop any running animation and timers, then show death frame
            kid.bodySprite.stop();
            if (kid.walkTimer) kid.walkTimer.remove();
            if (kid.moveTimer) kid.moveTimer.remove();
            kid.bodySprite.setFrame('death_0');
            
            this.checkWinCondition();
        } else {
            // Hit but not dead - show hit animation sequence
            if (kid.teamType === 'player') {
                // Red team hit animation: recursive loop like original (5 iterations)
                // hit -> hit1 -> hit2 -> hit3 -> repeat 5x -> standing
                this.playerHitAnimation(kid, 1);
            } else {
                // Green team hit animation depends on remaining health
                if (kid.health >= 2) {
                    // Normal hit: hit_0 -> guard -> brushOff -> back to idle
                    kid.bodySprite.setFrame('hit_0');
                    this.time.delayedCall(200, () => {
                        if (!kid.isAlive) return;
                        kid.bodySprite.setFrame('guard');
                    });
                    this.time.delayedCall(350, () => {
                        if (!kid.isAlive) return;
                        kid.bodySprite.setFrame('brushOff');
                    });
                    this.time.delayedCall(1200, () => {
                        if (!kid.isAlive) return;
                        kid.bodySprite.play('green_idle');
                        kid.isStunned = false;  // Can be hit again
                    });
                } else {
                    // One hit from death: show stunned frame (longer recovery)
                    kid.bodySprite.setFrame('stunned');
                    this.time.delayedCall(2400, () => {
                        if (!kid.isAlive) return;
                        kid.bodySprite.play('green_idle');
                        kid.isStunned = false;  // Can be hit again
                    });
                }
            }
        }
    }

    // Recursive hit animation for red team players (like original)
    // Original loops hit -> hit1 -> hit2 -> hit3 -> repeat 5 times -> standing
    playerHitAnimation(kid, count) {
        if (!kid.isAlive) return;
        
        if (count < 5) {
            let initialWait = 0;
            
            if (count === 1) {
                kid.bodySprite.setFrame('hit_0');  // 'hit' in original
            } else {
                initialWait = -250;
            }
            
            this.time.delayedCall(initialWait + 250, () => {
                if (!kid.isAlive) return;
                kid.bodySprite.setFrame('hit_1');
            });
            
            this.time.delayedCall(initialWait + 325, () => {
                if (!kid.isAlive) return;
                kid.bodySprite.setFrame('hit_2');
            });
            
            this.time.delayedCall(initialWait + 450, () => {
                if (!kid.isAlive) return;
                kid.bodySprite.setFrame('hit_3');
            });
            
            this.time.delayedCall(initialWait + 575, () => {
                if (!kid.isAlive) return;
                this.playerHitAnimation(kid, count + 1);
            });
        } else {
            kid.bodySprite.play('red_idle');
            kid.isStunned = false;  // Can be hit again
        }
    }

    checkWinCondition() {
        let greenAlive = this.greenTeam.filter(k => k.isAlive).length;
        let redAlive = this.redTeam.filter(k => k.isAlive).length;
        if (greenAlive === 0) {
            this.isLevelActive = false;
            // Stop all enemy movement timers
            this.greenTeam.forEach(enemy => {
                if (enemy.moveTimer) enemy.moveTimer.remove();
            });
            this.time.delayedCall(2000, () => this.startLevel(this.currentLevelIndex + 1));
        } else if (redAlive === 0) {
            this.isLevelActive = false;
            // Stop all enemy movement timers
            this.greenTeam.forEach(enemy => {
                if (enemy.moveTimer) enemy.moveTimer.remove();
                if (enemy.isAlive) {
                    enemy.bodySprite.play('green_victory');
                }
            });
            
            this.levelText.setText("GAME OVER");
            this.levelText.setVisible(true);
            this.levelText.alpha = 1;
            this.input.once('pointerdown', () => location.reload());
        }
    }

        // Calculate a random destination within the valid enemy zone (upper-left triangle)
    calcEnemyPosition(enemy) {
        const walkingDistance = 3;
        // Random offset 0-200 pixels (independent X and Y for more natural movement)
        let offsetX = Phaser.Math.Between(0, Math.floor(200 / walkingDistance)) * walkingDistance;
        let offsetY = Phaser.Math.Between(0, Math.floor(200 / walkingDistance)) * walkingDistance;
        
        // Random direction for each axis independently
        if (Phaser.Math.Between(0, 1) === 0) offsetX = -offsetX;
        if (Phaser.Math.Between(0, 1) === 0) offsetY = -offsetY;
        
        let newX = enemy.x + offsetX;
        let newY = enemy.y + offsetY;
        
        // Snap to walking grid
        newX = Math.round(newX / walkingDistance) * walkingDistance;
        newY = Math.round(newY / walkingDistance) * walkingDistance;
        
        // Validate position is in enemy zone (upper-left triangle)
        // Triangle: (0,0) -> (0, 160) -> (250, 0) - Stop before ice wall
        if (!this.isValidEnemyPosition(newX, newY)) {
            // Try again with a new random position
            return this.calcEnemyPosition(enemy);
        }
        
        enemy.finalX = newX;
        enemy.finalY = newY;
    }
    
    // Check if position is within enemy movement zone (upper-left triangle)
    isValidEnemyPosition(x, y) {
        // Enemy zone is upper-left triangle
        // Boundaries: x >= 30, y >= 25 (lowered to include spawn points), and below diagonal
        // Restricted max X to 250 to prevent walking on/through the ice wall
        if (x < 30 || x > 250) return false;
        if (y < 25 || y > 160) return false;
        
        // Check diagonal boundary: y should be less than the line from (360,50) to (30,160)
        // Line equation: y = 50 + (110 * (360 - x)) / 330
        let maxY = 50 + (110 * (360 - x)) / 330;
        return y <= maxY;
    }
    
    // Start enemy walking movement
    startEnemyMovement(enemy) {
        if (!enemy.isAlive || !this.isLevelActive) return;
        if (enemy.moveTimer) enemy.moveTimer.remove();
        
        const walkingDistance = 3;
        const walkingFps = 4; // Reduced to 4 (from 5) to slow down movement
        const frameDelay = Math.round(1000 / 60 * walkingFps); 
        
        enemy.isWalking = true;
        enemy.bodySprite.setFrame('walking');
        
        enemy.moveTimer = this.time.addEvent({
            delay: frameDelay,
            callback: () => {
                if (!enemy.isAlive || !this.isLevelActive) {
                    if (enemy.moveTimer) enemy.moveTimer.remove();
                    return;
                }
                
                let dx = enemy.finalX - enemy.x;
                let dy = enemy.finalY - enemy.y;
                let moving = false;
                
                // Move toward destination
                if (Math.abs(dx) >= walkingDistance) {
                    enemy.x += (dx > 0) ? walkingDistance : -walkingDistance;
                    moving = true;
                }
                if (Math.abs(dy) >= walkingDistance) {
                    enemy.y += (dy > 0) ? walkingDistance : -walkingDistance;
                    moving = true;
                }
                
                if (enemy.shadow) enemy.shadow.setPosition(enemy.x + 20, enemy.y);

                if (moving) {
                    // Toggle walk animation
                    enemy.isWalking = !enemy.isWalking;
                    enemy.bodySprite.setFrame(enemy.isWalking ? 'walking' : 'walkingAlt');
                } else {
                    // Reached destination
                    enemy.moveTimer.remove();
                    
                    // Logic to make them walk randomly 1-2 segments before throwing
                    if (typeof enemy.walkSegments === 'undefined') enemy.walkSegments = 0;
                    enemy.walkSegments++;
                    
                    // Randomly decide how many segments to walk (1 to 2) before throwing
                    const segmentsNeeded = Phaser.Math.Between(1, 2);
                    
                    if (enemy.walkSegments >= segmentsNeeded) {
                        // Reset counter and throw
                        enemy.walkSegments = 0;
                        this.enemyThrowSnowball(enemy);
                    } else {
                        // Pick another destination and keep walking
                        // Add a small pause before next movement for natural feel
                        this.time.delayedCall(200, () => {
                            if (enemy.isAlive && this.isLevelActive) {
                                this.calcEnemyPosition(enemy);
                                this.startEnemyMovement(enemy);
                            }
                        });
                    }
                }
            },
            loop: true
        });
    }
    
    // Enemy throwing sequence
    enemyThrowSnowball(enemy) {
        if (!enemy.isAlive || !this.isLevelActive) return;
        
        // Get target
        let targets = this.redTeam.filter(k => k.isAlive);
        if (targets.length === 0) return;
        let target = targets[Phaser.Math.Between(0, targets.length - 1)];
        
        // Add error based on difficulty
        let error = Phaser.Math.FloatBetween(-this.currentConfig.errorMargin, this.currentConfig.errorMargin);
        let targetX = target.x + (error * 100);
        let targetY = target.y + (error * 50);
        let power = Phaser.Math.Between(50, 90);
        
        // Gathering pose
        enemy.bodySprite.setFrame('throw_0');
        
        this.time.delayedCall(300, () => {
            if (!enemy.isAlive) return;
            // Cocked pose
            enemy.bodySprite.setFrame('throw_1');
        });
        
        this.time.delayedCall(750, () => {
            if (!enemy.isAlive) return;
            // Throwing pose + throw
            enemy.bodySprite.setFrame('throw_2');
            this.throwSnowball(enemy, power, targetX, targetY);
        });
        
        this.time.delayedCall(1000, () => {
            if (!enemy.isAlive) return;
            // Back to walking - pick new destination
            this.calcEnemyPosition(enemy);
            this.startEnemyMovement(enemy);
        });
    }

    createSnowSplash(x, y) {
        let splash = this.add.image(x, y, 'splash').setDepth(50);
        
        this.time.delayedCall(120, () => {
            splash.setTexture('sink');
            this.time.delayedCall(120, () => {
                splash.setTexture('puddle');
                this.tweens.add({
                    targets: splash,
                    alpha: 0,
                    duration: 1000,
                    delay: 500,
                    onComplete: () => splash.destroy()
                });
            });
        });
    }

    playRandomSound(key, volume = 1) {
        let soundKey = key;
        
        if (key === 'sfx_hit') {
            const variation = Phaser.Math.Between(1, 3);
            soundKey = key + variation;
        }
        
        if (this.sound.get(soundKey)) {
             let detune = Phaser.Math.Between(-200, 200); 
             this.sound.play(soundKey, { detune: detune, volume: volume });
        }
    }
    
    movePlayer(kid, x, y) {
        x = Phaser.Math.Clamp(x, 40, 260); 
        y = Phaser.Math.Clamp(y, 70, 300);

        this.createSnowSplash(x, y); 
        this.playRandomSound('sfx_step', 0.2); 

        this.tweens.add({
            targets: kid,
            x: x,
            y: y,
            duration: Phaser.Math.Distance.Between(kid.x, kid.y, x, y) * 5,
            onStart: () => { if(kid.bodySprite.anims.exists('red_walk')) kid.bodySprite.play('red_walk'); },
            onUpdate: () => {
                if (kid.shadow) kid.shadow.setPosition(kid.x + 20, kid.y);
            },
            onComplete: () => { if(kid.isAlive) kid.bodySprite.play('red_idle'); }
        });
    }

    getClosestActive(team, pointer, maxDist = 1000) {
        // Match original: check if click is within player bounding box
        // Only allow selection of alive players who aren't walking onto field
        let clicked = null;
        team.forEach(kid => {
            if (!kid.isAlive) return;
            if (kid.isWalkingOntoField) return; // Can't select players still walking onto field
            // Use bounding box detection like original game
            // Original uses top-left origin, Phaser container is centered
            // Player sprite is roughly 30x35, use slightly larger hitbox for better UX
            let width = 35;
            let height = 45;
            // Offset to account for sprite alignment in container
            let hitX = kid.x - width / 2;
            let hitY = kid.y - height / 2;
            if (pointer.x >= hitX &&
                pointer.x <= hitX + width &&
                pointer.y >= hitY &&
                pointer.y <= hitY + height) {
                clicked = kid;
            }
        });
        return clicked;
    }

    // Show selection circle when hovering over player
    showSelectionUI(player) {
        // Draw selection circle (solid ellipse for ground perspective)
        this.selectionCircle.clear();
        this.selectionCircle.lineStyle(2, 0x0088cc, 1);
        this.selectionCircle.strokeEllipse(0, 0, 60, 30);
        this.selectionCircle.setPosition(player.x, player.y + 15);
        this.selectionCircle.setVisible(true);
    }
    
    // Show power meter when mousedown on player
    showPowerMeter(player) {
        this.powerMeterContainer.setPosition(player.x + 25, player.y + 20);
        this.powerMeterContainer.setVisible(true);
        this.updatePowerMeter();
    }
    
    // Update selection UI position to follow player
    updateSelectionUI(player) {
        if (!player) return;
        this.selectionCircle.setPosition(player.x, player.y + 15);
        if (this.powerMeterContainer.visible) {
            this.powerMeterContainer.setPosition(player.x + 25, player.y + 20);
        }
    }
    
    // Hide selection circle (when mouse leaves player)
    hideSelectionUI() {
        this.selectionCircle.setVisible(false);
        this.powerMeterContainer.setVisible(false);
    }
    
    // Hide power meter only (selection circle stays)
    hidePowerMeter() {
        this.powerMeterContainer.setVisible(false);
    }
    
    // Update power meter bars based on current strength
    updatePowerMeter() {
        const barsToShow = Math.ceil((this.activeStrength / this.maxStrength) * this.powerMeterBars.length);
        this.powerMeterBars.forEach((bar, index) => {
            bar.setVisible(index < barsToShow);
        });
    }
    
    // Draw a dashed ellipse (orthogonal/ground perspective)
    drawDashedEllipse(graphics, x, y, radiusX, radiusY, numDashes, gapAngle) {
        const totalAngle = 2 * Math.PI;
        const segmentAngle = totalAngle / numDashes;
        const dashAngle = segmentAngle * 0.7; // 70% dash, 30% gap
        
        for (let i = 0; i < numDashes; i++) {
            const startAngle = i * segmentAngle;
            const endAngle = startAngle + dashAngle;
            
            // Draw ellipse arc segment using individual line segments
            const steps = 12;
            let firstPoint = true;
            for (let j = 0; j <= steps; j++) {
                const angle = startAngle + (endAngle - startAngle) * (j / steps);
                const px = x + radiusX * Math.cos(angle);
                const py = y + radiusY * Math.sin(angle);
                
                if (j < steps) {
                    const nextAngle = startAngle + (endAngle - startAngle) * ((j + 1) / steps);
                    const nx = x + radiusX * Math.cos(nextAngle);
                    const ny = y + radiusY * Math.sin(nextAngle);
                    graphics.lineBetween(px, py, nx, ny);
                }
            }
        }
    }
}

game = new Phaser.Game(getConfig());
</script>
</body>
</html>