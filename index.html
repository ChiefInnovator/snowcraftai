<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snowcraft Reforged</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        body { margin: 0; background: #222; overflow: hidden; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: 'Arial', sans-serif; }
        #game-container { box-shadow: 0 0 30px rgba(0,0,0,0.8); border: 4px solid #fff; border-radius: 8px; line-height: 0; }
        #game-container canvas { display: block; }
    </style>
</head>
<body>

<div id="game-container"></div>

<script>
// --- CONFIGURATION ---
const DEBUG_MODE = false; // Set to false to hide coordinate labels

const LEVEL_CONFIG = [
    { level: 1, enemies: 3, fireInterval: 2000, errorMargin: 0.35 }, 
    { level: 2, enemies: 3, fireInterval: 1500, errorMargin: 0.25 },
    { level: 3, enemies: 4, fireInterval: 1200, errorMargin: 0.15 },
    { level: 4, enemies: 5, fireInterval: 900,  errorMargin: 0.08 },
    { level: 5, enemies: 6, fireInterval: 700,  errorMargin: 0.05 },
];

class MainScene extends Phaser.Scene {
    constructor() {
        super({ key: 'MainScene' });
    }

    preload() {
        // --- ASSET LOADING ---
        this.load.image('red_team_atlas', 'assets/player.png');
        this.load.image('green_team_atlas', 'assets/enemy.png');
        this.load.image('snowball', 'assets/snowball.png');
        this.load.image('splash', 'assets/splash.png');
        this.load.image('sink', 'assets/sink.png');
        this.load.image('puddle', 'assets/puddle.png');
        this.load.image('playfield', 'assets/playField.png');
        this.load.image('shadow', 'assets/shadow.png');
        this.load.image('snowball_shadow', 'assets/snowball_shadow.png');
        this.load.image('hand', 'assets/smallHand.png');
        
        // Audio
        this.load.audio('sfx_throw', 'assets/throw.mp3');
        this.load.audio('sfx_hit1', 'assets/hit1.mp3');
        this.load.audio('sfx_hit2', 'assets/hit2.mp3');
        this.load.audio('sfx_hit3', 'assets/hit3.mp3');
        this.load.audio('sfx_deathHit', 'assets/deathHit.mp3');
        this.load.audio('sfx_intro', 'assets/intro.mp3');
        this.load.audio('sfx_introAlt', 'assets/introAlt.mp3');
        this.load.audio('music', 'assets/musicAlt.mp3');
    }

    create() {
        // 1. Environment
        let bg = this.add.graphics();
        bg.fillGradientStyle(0xddeeff, 0xddeeff, 0xffffff, 0xffffff, 1);
        bg.fillRect(0, 0, 600, 320);
        bg.setDepth(-10);

        // Add Playfield Overlay
        if (this.textures.exists('playfield')) {
            let pf = this.add.image(300, 160, 'playfield');
            pf.setDisplaySize(600, 320);
            pf.setDepth(-5);
        }

        // 2. Define Frames & Animations
        // Red Team
        const redTex = this.textures.get('red_team_atlas');
        redTex.add('idle_0', 0, 148, 19, 26, 34);
        redTex.add('walking', 0, 15, 19, 24, 34);
        redTex.add('walkingAlt', 0, 59, 18, 30, 35);
        redTex.add('throw_0', 0, 84, 99, 31, 35);
        redTex.add('throw_1', 0, 150, 98, 23, 36);
        redTex.add('hit_0', 0, 199, 24, 35, 30);
        redTex.add('hit_1', 0, 258, 11, 32, 43);
        redTex.add('hit_2', 0, 312, 10, 36, 44);
        redTex.add('hit_3', 0, 368, 13, 35, 40);
        redTex.add('death_0', 0, 208, 109, 71, 32);
        redTex.add('hardDeath', 0, 290, 101, 68, 48);
        redTex.add('wipedOut', 0, 376, 98, 51, 53);

        // Green Team
        const greenTex = this.textures.get('green_team_atlas');
        greenTex.add('idle_0', 0, 133, 18, 30, 36);
        greenTex.add('idle_1', 0, 186, 18, 27, 34);
        greenTex.add('walking', 0, 133, 18, 30, 36);
        greenTex.add('walkingAlt', 0, 186, 18, 27, 34);
        greenTex.add('throw_0', 0, 292, 23, 24, 31);
        greenTex.add('throw_1', 0, 332, 19, 34, 35);
        greenTex.add('throw_2', 0, 393, 20, 24, 34);
        greenTex.add('hit_0', 0, 26, 75, 25, 35);
        greenTex.add('guard', 0, 74, 75, 29, 35);
        greenTex.add('brushOff', 0, 124, 75, 29, 35);
        greenTex.add('stunned', 0, 170, 76, 35, 34);
        greenTex.add('death_0', 0, 44, 145, 66, 42);
        greenTex.add('hardDeath', 0, 137, 142, 54, 46);
        greenTex.add('wipedOut', 0, 220, 145, 69, 42);
        greenTex.add('minorDeath', 0, 317, 145, 49, 38);
        greenTex.add('victory_0', 0, 244, 78, 42, 35);
        greenTex.add('victory_1', 0, 312, 77, 40, 37);
        greenTex.add('victory_2', 0, 380, 76, 42, 37);

        // Animations
        this.anims.create({ key: 'red_idle', frames: [{ key: 'red_team_atlas', frame: 'idle_0' }], frameRate: 1, repeat: -1 });
        this.anims.create({ key: 'red_walk', frames: [{ key: 'red_team_atlas', frame: 'walking' }, { key: 'red_team_atlas', frame: 'walkingAlt' }], frameRate: 5, repeat: -1 });
        this.anims.create({ key: 'red_throw', frames: [{ key: 'red_team_atlas', frame: 'throw_0' }, { key: 'red_team_atlas', frame: 'throw_1' }], frameRate: 10, repeat: 0 });
        
        this.anims.create({ key: 'green_idle', frames: [{ key: 'green_team_atlas', frame: 'idle_0' }, { key: 'green_team_atlas', frame: 'idle_1' }], frameRate: 4, repeat: -1 });
        this.anims.create({ key: 'green_walk', frames: [{ key: 'green_team_atlas', frame: 'walking' }, { key: 'green_team_atlas', frame: 'walkingAlt' }], frameRate: 5, repeat: -1 });
        this.anims.create({ key: 'green_throw', frames: [{ key: 'green_team_atlas', frame: 'throw_0' }, { key: 'green_team_atlas', frame: 'throw_1' }, { key: 'green_team_atlas', frame: 'throw_2' }], frameRate: 10, repeat: 0 });

        this.anims.create({ key: 'red_death', frames: [{ key: 'red_team_atlas', frame: 'death_0' }], frameRate: 1, repeat: 0 });
        this.anims.create({ 
            key: 'green_victory', 
            frames: [{ key: 'green_team_atlas', frame: 'victory_0' }, { key: 'green_team_atlas', frame: 'victory_1' }, { key: 'green_team_atlas', frame: 'victory_2' }], 
            frameRate: 4, repeat: -1 
        });

        // 3. Game Groups & State
        this.projectiles = this.add.group();
        this.redTeam = [];
        this.greenTeam = [];
        this.isLevelActive = false; // Must be false until players finish walking
        this.isDragging = false;
        this.dragStartX = 0;
        this.dragStartY = 0;
        this.dragOriginX = 0;
        this.dragOriginY = 0;
        this.activeStrength = 1;
        this.maxStrength = 100;
        
        // 4. UI Elements
        this.strengthText = this.add.text(0, 0, '', { fontSize: '8px', color: '#ff0000', fontFamily: 'Arial' }).setDepth(100).setVisible(false);
        this.levelText = this.add.text(300, 160, '', { fontSize: '60px', color: '#cc0000', fontStyle: 'bold', stroke: '#fff', strokeThickness: 6 }).setOrigin(0.5).setDepth(200).setVisible(false);

        // Selection Circle (dashed blue circle like original)
        this.selectionCircle = this.add.graphics();
        this.selectionCircle.setDepth(-1);  // Draw behind player
        this.selectionCircle.setVisible(false);
        
        // Power Meter Bars (green bars like original)
        this.powerMeterBars = [];
        this.powerMeterContainer = this.add.container(0, 0).setDepth(100).setVisible(false);
        const barWidth = 12;
        const barHeight = 4;
        const barGap = 2;
        const numBars = 8;
        for (let i = 0; i < numBars; i++) {
            let bar = this.add.graphics();
            bar.fillStyle(0x00ff00, 1); // Green color
            bar.fillRect(0, 0, barWidth, barHeight);
            bar.lineStyle(1, 0x006600, 1); // Dark green border
            bar.strokeRect(0, 0, barWidth, barHeight);
            bar.y = -i * (barHeight + barGap);
            this.powerMeterContainer.add(bar);
            this.powerMeterBars.push(bar);
        }

        // Custom Cursor
        this.input.setDefaultCursor('url(assets/smallHand.png), pointer');
        
        // Music
        this.music = this.sound.add('music', { loop: true, volume: 0.3 });
        
        // 5. Inputs
        this.input.mouse.disableContextMenu(); 
        this.hoveredPlayer = null;

        // Hover detection - show selection circle when mouse is over a player
        this.input.on('pointermove', (pointer) => {
            // No selection allowed until level is active (players finished walking)
            if (!this.isLevelActive) {
                if (this.hoveredPlayer) {
                    this.hideSelectionUI();
                    this.hoveredPlayer = null;
                }
                return;
            }
            
            // If dragging, move the player and update UI
            if (this.isDragging && this.activePlayer && this.activePlayer.isAlive) {
                this.activePlayer.x = Math.round(pointer.x);
                this.activePlayer.y = Math.round(pointer.y);
                this.activePlayer.bodySprite.setFrame('throw_0');
                this.updateSelectionUI(this.activePlayer);
                return;
            }
            
            // Check if hovering over a player
            let hovered = this.getClosestActive(this.redTeam, pointer, 40);
            
            if (hovered && hovered.isAlive) {
                // Show selection on new hovered player
                if (this.hoveredPlayer !== hovered) {
                    this.hoveredPlayer = hovered;
                    this.showSelectionUI(hovered);
                } else {
                    // Update position in case player moved
                    this.updateSelectionUI(hovered);
                }
            } else {
                // Not hovering over any player - hide selection
                if (this.hoveredPlayer) {
                    this.hideSelectionUI();
                    this.hoveredPlayer = null;
                }
            }
        });

        // Mousedown - start power meter if hovering over a player
        this.input.on('pointerdown', (pointer) => {
            if (!this.isLevelActive) return;
            if (this.isDragging) return;

            if (pointer.leftButtonDown() && this.hoveredPlayer && this.hoveredPlayer.isAlive) {
                this.activePlayer = this.hoveredPlayer;
                this.isDragging = true;
                this.activeStrength = 1;
                // Store original position
                this.dragOriginX = this.activePlayer.x;
                this.dragOriginY = this.activePlayer.y;
                this.dragStartX = pointer.x;
                this.dragStartY = pointer.y;
                // Show cocked sprite
                this.activePlayer.bodySprite.setFrame('throw_0');
                // Show power meter (selection circle already visible from hover)
                this.showPowerMeter(this.activePlayer);
                // Start increasing strength (power meter)
                this.increaseStrength();
            }
        });

        this.input.on('pointerup', (pointer) => {
            if (this.isDragging && this.activePlayer && this.isLevelActive && pointer.leftButtonReleased()) {
                // Original behavior: player stays where dragged, doesn't snap back
                // Throw from current position with accumulated strength
                this.throwSnowball(this.activePlayer, this.activeStrength, 0, 0);
                
                // Reset to idle animation (player stays at current position)
                this.activePlayer.bodySprite.play('red_idle');
                
                // Hide power meter only (selection circle stays if still hovering)
                this.hidePowerMeter();
                
                this.isDragging = false;
                this.activeStrength = 1;
                this.strengthText.setVisible(false);
                
                // Update hovered player to current position
                this.hoveredPlayer = this.activePlayer;
                this.activePlayer = null;
            }
        });
        
        // Handle pointer leaving game area - cancel drag without throwing
        this.input.on('pointerupoutside', (pointer) => {
            if (this.isDragging && this.activePlayer) {
                this.activePlayer.bodySprite.play('red_idle');
                this.hidePowerMeter();
                this.hideSelectionUI();
                this.isDragging = false;
                this.activeStrength = 1;
                this.strengthText.setVisible(false);
                this.hoveredPlayer = null;
                this.activePlayer = null;
            }
        });

        this.startLevel(0);
    }

    startLevel(index) {
        this.currentLevelIndex = index;
        let config = LEVEL_CONFIG[index] || LEVEL_CONFIG[LEVEL_CONFIG.length - 1];
        this.currentConfig = config;
        
        let isIntro = (index === 0);
        
        if (isIntro) {
            this.sound.play('sfx_intro', { volume: 0.6 });
            if (!this.music.isPlaying) {
                this.music.play();
            }
        }

        this.greenTeam.forEach(k => k.destroy());
        this.greenTeam = [];
        this.projectiles.clear(true, true);

        if (isIntro) {
            this.redTeam.forEach(k => k.destroy());
            this.redTeam = [];
            this.createTeam('player', this.redTeam, 3, true); 
        } else {
            if (this.redTeam.length === 0) {
                this.createTeam('player', this.redTeam, 3, false);
            } else {
                this.redTeam.forEach(kid => {
                    kid.isAlive = true;
                    kid.health = 3;  // Reset health
                    kid.isStunned = false;
                    kid.visible = true;
                    kid.alpha = 1;
                    kid.angle = 0;
                    kid.setScale(1);  // Reset scale after death animation
                    kid.bodySprite.play('red_idle');
                    kid.bodySprite.setTint(0xffffff);
                });
            }
        }

        this.createTeam('cpu', this.greenTeam, config.enemies, isIntro);

        let message = isIntro ? "Season's Greetings" : 'LEVEL ' + (index + 1);
        
        this.levelText.setText(message);
        this.levelText.setStyle({ 
            fontSize: isIntro ? '40px' : '60px',
            fontFamily: isIntro ? 'Georgia, serif' : 'Arial, sans-serif'
        });
        
        this.levelText.setVisible(true);
        this.levelText.alpha = 0;
        this.levelText.y = 160;
        this.isLevelActive = false;

        this.walkingCount = 0; // Track walking players
        this.textFadeComplete = false;
        this.pendingFireInterval = config.fireInterval;

        this.tweens.add({
            targets: this.levelText,
            alpha: 1,
            duration: 1000,
            hold: isIntro ? 2500 : 1500, 
            yoyo: true,
            onComplete: () => {
                this.textFadeComplete = true;
                this.checkLevelReady();
            }
        });
    }

    checkLevelReady() {
        // Only activate level when text has faded AND all walking is complete
        // Guard against being called multiple times
        if (this.isLevelActive) return;
        
        if (this.textFadeComplete && this.walkingCount === 0) {
            this.isLevelActive = true;
            this.setupAITimer(this.pendingFireInterval);
        }
    }

    createTeam(type, teamArray, count, isIntro = false) {
        const textureKey = (type === 'player') ? 'red_team_atlas' : 'green_team_atlas';
        const prefix = (type === 'player') ? 'red' : 'green';

        // Fixed positions matching original game (scaled to 600x320)
        const playerPositions = [
            { x: 500, y: 180 },  // Top-right red
            { x: 360, y: 265 },  // Bottom-left red  
            { x: 470, y: 275 },  // Bottom-middle red
            { x: 500, y: 270 },  // Right-middle red
            { x: 450, y: 275 },
            { x: 420, y: 300 }
        ];
        const enemyPositions = [
            { x: 95, y: 35 },    // Top-left green
            { x: 200, y: 30 },   // Top-right green
            { x: 70, y: 105 },   // Bottom-left green
            { x: 140, y: 70 },   // Extra positions if needed
            { x: 160, y: 120 },
            { x: 100, y: 90 }
        ];

        for (let i = 0; i < count; i++) {
            // Use fixed positions from original game
            let finalPos = (type === 'player') 
                ? playerPositions[i % playerPositions.length]
                : enemyPositions[i % enemyPositions.length];
            let finalX = finalPos.x;
            let finalY = finalPos.y;
            
            // --- DIAGONAL WALK-IN LOGIC ---
            let spawnX, spawnY;
            // Use a significant offset (e.g., 250px) to ensure they start well off-screen
            // and walk a clear diagonal path roughly 45 degrees.
            let offset = 250; 

            if (isIntro) {
                if (type === 'player') {
                    // Red Team (Right Side)
                    // Enters from Bottom-Right -> Walks Up-Left
                    spawnX = finalX + offset; 
                    spawnY = finalY + offset; 
                } else {
                    // Green Team (Left Side)
                    // Enters from Top-Left -> Walks Down-Right
                    spawnX = finalX - offset; 
                    spawnY = finalY - offset; 
                }
            } else {
                spawnX = finalX;
                spawnY = finalY;
            }
            
            let kid = this.add.container(spawnX, spawnY);
            
            // Shadow positioned for isometric view (added first so it renders behind sprite)
            let shadow = this.add.image(20, 0, 'shadow');
            shadow.setScale(1.2);
            shadow.setAlpha(0.6);
            kid.add(shadow);
            
            let sprite = this.add.sprite(0, 0, textureKey);
            sprite.setFlipX(false); // Assumes atlases are correctly oriented (Red=Left, Green=Right)
            
            kid.add(sprite);
            kid.isAlive = true;
            kid.teamType = type;
            kid.bodySprite = sprite;
            kid.health = (type === 'player') ? 3 : 4;  // Players take 3 hits, enemies take 4
            kid.isStunned = false;  // Prevents taking damage while in hit animation
            kid.setSize(30, 50);

            // Debug label showing coordinates
            if (DEBUG_MODE) {
                kid.debugLabel = this.add.text(0, -45, '', { 
                    fontSize: '10px', 
                    color: '#000000', 
                    backgroundColor: '#ffffff',
                    padding: { x: 2, y: 1 }
                }).setOrigin(0.5).setDepth(1000);
            }

            teamArray.push(kid);

            if (isIntro) {
                const walkingDistance = 3; 
                
                kid.walkFrame = 0;
                kid.isWalking = true;  // Animation toggle
                kid.isWalkingOntoField = true;  // Track if still entering field
                kid.finalX = finalX;
                kid.finalY = finalY;
                this.walkingCount++;
                
                sprite.setFrame('walking');
                
                kid.walkTimer = this.time.addEvent({
                    delay: 83, 
                    callback: () => {
                        let dx = kid.finalX - kid.x;
                        let dy = kid.finalY - kid.y;
                        
                        // Check arrival
                        if (Math.abs(dx) <= walkingDistance && Math.abs(dy) <= walkingDistance) {
                            kid.x = kid.finalX;
                            kid.y = kid.finalY;
                            kid.isWalkingOntoField = false;  // Player has arrived on field
                            sprite.play(prefix + '_idle'); 
                            kid.walkTimer.remove();
                            this.walkingCount--;
                            this.checkLevelReady();
                            return;
                        }
                        
                        // Move diagonally
                        if (Math.abs(dx) > 0) {
                            kid.x += (dx > 0) ? walkingDistance : -walkingDistance;
                        }
                        if (Math.abs(dy) > 0) {
                            kid.y += (dy > 0) ? walkingDistance : -walkingDistance;
                        }
                        
                        // Toggle animation
                        kid.isWalking = !kid.isWalking;
                        sprite.setFrame(kid.isWalking ? 'walking' : 'walkingAlt');
                    },
                    loop: true
                });
            } else {
                sprite.playAfterDelay(prefix + '_idle', Math.random() * 1000);
            }
        }
    }

    // Increase strength while dragging - exponential acceleration
    increaseStrength() {
        if (this.isDragging && this.activeStrength < this.maxStrength) {
            // Exponential acceleration: delay decreases exponentially as strength increases
            // Formula: delay = baseDelay * e^(-k * strength)
            // This creates smooth exponential speedup
            let baseDelay = 20;  // Faster base delay (was 50)
            let k = 0.04; // Faster acceleration ramp (was 0.03)
            let delay = Math.max(3, Math.floor(baseDelay * Math.exp(-k * this.activeStrength)));
            
            this.activeStrength++;
            this.time.delayedCall(delay, () => this.increaseStrength());
        }
    }

    update(time, delta) {
        // Update power meter while dragging
        if (this.isDragging && this.activePlayer) {
            this.updatePowerMeter();
            // Update selection UI position to follow player
            this.updateSelectionUI(this.activePlayer);
        }

        // Update debug labels
        if (DEBUG_MODE) {
            [...this.redTeam, ...this.greenTeam].forEach(kid => {
                if (kid.debugLabel) {
                    // Position above player, or below if near top of screen
                    let labelY = (kid.y - 45 < 10) ? kid.y + 35 : kid.y - 45;
                    kid.debugLabel.setPosition(kid.x, labelY);
                    kid.debugLabel.setText(`${Math.round(kid.x)}, ${Math.round(kid.y)}`);
                    kid.debugLabel.setVisible(kid.isAlive);
                }
            });
        }

        [...this.projectiles.getChildren()].forEach(ball => {
            // Bezier curve trajectory (like original)
            if (ball.position !== undefined && ball.position < 1.0) {
                // Speed based on strength - higher power = faster ball
                // Minimum speed of 0.05, scales up with strength (max ~0.08 at full power)
                let buffer = 0.05 + (ball.strength / 100) * 0.03;
                ball.position = (ball.position + buffer);
                
                if (ball.position >= 1.0) {
                    // Snowball landed
                    this.createSnowSplash(ball.x, ball.y);
                    if (ball.shadow) ball.shadow.destroy();
                    ball.destroy();
                    return;
                }
                
                // Quadratic Bezier calculation
                let t = ball.position;
                let iT = 1 - t;
                ball.x = Math.round(iT * iT * ball.startX + 2 * iT * t * ball.cpX + t * t * ball.endX);
                ball.y = Math.round(iT * iT * ball.startY + 2 * iT * t * ball.cpY + t * t * ball.endY);
                
                // Shadow follows ground position
                let groundY = (((ball.x - ball.startX) / (ball.endX - ball.startX) * (ball.endY - ball.startY)) + ball.startY);
                if (ball.shadow) {
                    ball.shadow.setPosition(ball.x, groundY);
                }
                
                // Check if out of bounds
                if (ball.x < 0 || ball.y < 0 || ball.x > 600 || ball.y > 320) {
                    if (ball.shadow) ball.shadow.destroy();
                    ball.destroy();
                    return;
                }
                
                // Hit detection during arc
                let targetTeam = (ball.throwerTeam === 'player') ? this.greenTeam : this.redTeam;
                targetTeam.forEach(enemy => {
                    if (enemy.isAlive && !enemy.isStunned &&
                        ball.x > enemy.x - 10 &&
                        ball.x < enemy.x + 30 &&
                        ball.y > enemy.y - 10 &&
                        ball.y < enemy.y + 50) {
                        this.handleHit(enemy, ball);
                    }
                });
            } else if (ball.zSpeed !== undefined) {
                // Fallback for old-style physics (CPU throws)
                ball.z += ball.zSpeed;
                ball.zSpeed -= 0.5;

                if (ball.z <= 0) {
                    ball.z = 0;
                    this.createSnowSplash(ball.x, ball.y);
                    if (ball.shadow) ball.shadow.destroy();
                    ball.destroy();
                } else {
                    ball.x += ball.vx;
                    ball.y += ball.vy;
                    
                    let scale = 1 + (ball.z / 300);
                    ball.setScale(scale);
                    
                    ball.shadow.setPosition(ball.x, ball.y + ball.z);
                    ball.shadow.setAlpha(Math.max(0.1, 0.6 - (ball.z / 100))); 

                    if (ball.z < 40 && ball.z > 5) {
                        let targetTeam = (ball.throwerTeam === 'player') ? this.greenTeam : this.redTeam;
                        targetTeam.forEach(enemy => {
                            if (enemy.isAlive && !enemy.isStunned && Phaser.Math.Distance.Between(ball.x, ball.y, enemy.x, enemy.y) < 30) {
                                this.handleHit(enemy, ball);
                            }
                        });
                    }
                }
            }
        });
    }

    throwSnowball(thrower, strength, targetX, targetY) {
        // Calculate distance based on strength (like original: baselineSnowballDistance * strength)
        let baselineDistance = 5;
        let distance = baselineDistance * strength;
        
        let ball = this.add.image(thrower.x + 5, thrower.y, 'snowball');
        ball.shadow = this.add.image(thrower.x + 5, thrower.y, 'snowball_shadow');
        ball.shadow.setAlpha(0.6);
        ball.throwerTeam = thrower.teamType;
        
        // Arc trajectory parameters
        ball.startX = thrower.x + 5;
        ball.startY = thrower.y;
        ball.strength = strength;
        ball.distance = distance;
        ball.position = 0.0;
        
        let angle = Phaser.Math.Angle.Between(thrower.x, thrower.y, targetX, targetY);
        
        // Calculate end point based on angle and distance
        // Isometric view: Y movement is ~half of X movement
        let arcHeight = Math.min(strength * 0.3, 30);
        let yDistance = distance * 0.5;  // Isometric ratio
        
        if (thrower.teamType === 'player') {
            // Player throws toward upper-left (toward enemies)
            ball.endX = ball.startX - distance;
            ball.endY = ball.startY - yDistance + 15;
            ball.cpX = ball.startX - (distance * 0.6);
            ball.cpY = ball.startY - (yDistance * 0.6) - arcHeight;
        } else {
            // Enemy throws toward player (right/down)
            ball.endX = ball.startX + distance;
            ball.endY = ball.startY + yDistance + 15;
            ball.cpX = ball.startX + (distance * 0.6);
            ball.cpY = ball.startY + (yDistance * 0.6) - arcHeight;
        }
        
        // For shadow tracking
        ball.z = 0;
        ball.zSpeed = 0;

        this.projectiles.add(ball);

        let prefix = (thrower.teamType === 'player') ? 'red' : 'green';
        // Show throwing frame
        thrower.bodySprite.setFrame('throw_1');
        this.time.delayedCall(100, () => {
            if(thrower.isAlive) thrower.bodySprite.play(prefix + '_idle');
        });
        this.playRandomSound('sfx_throw', 0.8);
    }

    handleHit(kid, ball) {
        // Ignore hits if already stunned or dead
        if (kid.isStunned || !kid.isAlive) return;
        
        ball.shadow.destroy();
        ball.destroy();
        
        kid.health--;
        kid.isStunned = true;  // Prevent multiple hits during animation
        
        this.playRandomSound('sfx_hit', 1.0);
        this.cameras.main.shake(100, 0.005);
        
        let prefix = (kid.teamType === 'player') ? 'red' : 'green';
        
        if (kid.health <= 0) {
            // Death - final hit
            kid.isAlive = false;
            this.sound.play('sfx_deathHit', { volume: 0.8 });
            
            kid.bodySprite.play(prefix + '_death');
            
            let splash = this.add.image(kid.x, kid.y + 10, 'splash').setDepth(kid.depth - 1);
            
            this.tweens.add({ 
                targets: kid, 
                angle: 90, 
                y: kid.y + 15,
                duration: 300,
                onComplete: () => {
                    splash.setTexture('sink');
                    
                    this.tweens.add({
                        targets: kid,
                        alpha: 0,
                        scaleX: 0.5,
                        scaleY: 0.5,
                        duration: 600,
                        onComplete: () => {
                            kid.setVisible(false);
                            
                            splash.setTexture('puddle');
                            
                            this.tweens.add({
                                targets: splash,
                                alpha: 0,
                                duration: 2000,
                                delay: 1000,
                                onComplete: () => splash.destroy()
                            });
                        }
                    });
                }
            });
            
            this.checkWinCondition();
        } else {
            // Hit but not dead - show hit animation sequence
            if (kid.teamType === 'player') {
                // Red team hit animation: hit_0 -> hit_1 -> hit_2 -> hit_3 -> back to idle
                kid.bodySprite.setFrame('hit_0');
                this.time.delayedCall(100, () => {
                    if (!kid.isAlive) return;
                    kid.bodySprite.setFrame('hit_1');
                });
                this.time.delayedCall(175, () => {
                    if (!kid.isAlive) return;
                    kid.bodySprite.setFrame('hit_2');
                });
                this.time.delayedCall(300, () => {
                    if (!kid.isAlive) return;
                    kid.bodySprite.setFrame('hit_3');
                });
                this.time.delayedCall(500, () => {
                    if (!kid.isAlive) return;
                    kid.bodySprite.play('red_idle');
                    kid.isStunned = false;  // Can be hit again
                });
            } else {
                // Green team hit animation depends on remaining health
                if (kid.health >= 2) {
                    // Normal hit: hit_0 -> guard -> brushOff -> back to idle
                    kid.bodySprite.setFrame('hit_0');
                    this.time.delayedCall(100, () => {
                        if (!kid.isAlive) return;
                        kid.bodySprite.setFrame('guard');
                    });
                    this.time.delayedCall(175, () => {
                        if (!kid.isAlive) return;
                        kid.bodySprite.setFrame('brushOff');
                    });
                    this.time.delayedCall(600, () => {
                        if (!kid.isAlive) return;
                        kid.bodySprite.play('green_idle');
                        kid.isStunned = false;  // Can be hit again
                    });
                } else {
                    // One hit from death: show stunned frame (longer recovery)
                    kid.bodySprite.setFrame('stunned');
                    this.time.delayedCall(1200, () => {
                        if (!kid.isAlive) return;
                        kid.bodySprite.play('green_idle');
                        kid.isStunned = false;  // Can be hit again
                    });
                }
            }
        }
    }

    checkWinCondition() {
        let greenAlive = this.greenTeam.filter(k => k.isAlive).length;
        let redAlive = this.redTeam.filter(k => k.isAlive).length;
        if (greenAlive === 0) {
            this.isLevelActive = false;
            if (this.aiTimer) this.aiTimer.remove();
            this.time.delayedCall(2000, () => this.startLevel(this.currentLevelIndex + 1));
        } else if (redAlive === 0) {
            this.isLevelActive = false;
            if (this.aiTimer) this.aiTimer.remove();
            
            this.greenTeam.forEach(enemy => {
                if (enemy.isAlive) {
                    enemy.bodySprite.play('green_victory');
                }
            });
            
            this.levelText.setText("GAME OVER");
            this.levelText.setVisible(true);
            this.levelText.alpha = 1;
            this.input.once('pointerdown', () => location.reload());
        }
    }

    setupAITimer(interval) {
        if (this.aiTimer) this.aiTimer.remove();
        this.aiTimer = this.time.addEvent({ delay: interval, callback: this.cpuThink, callbackScope: this, loop: true });
    }

    cpuThink() {
        if (!this.isLevelActive) return;
        let candidates = this.greenTeam.filter(k => k.isAlive);
        if (candidates.length === 0) return;
        let thrower = candidates[Phaser.Math.Between(0, candidates.length - 1)];
        let targets = this.redTeam.filter(k => k.isAlive);
        if (targets.length === 0) return;
        let target = targets[Phaser.Math.Between(0, targets.length - 1)];

        let error = Phaser.Math.FloatBetween(-this.currentConfig.errorMargin, this.currentConfig.errorMargin);
        let targetX = target.x + (error * 100);
        let targetY = target.y + (error * 50);

        let power = Phaser.Math.Between(50, 90);
        
        this.throwSnowball(thrower, power, targetX, targetY);
    }

    createSnowSplash(x, y) {
        let splash = this.add.image(x, y, 'splash').setDepth(50);
        
        this.time.delayedCall(120, () => {
            splash.setTexture('sink');
            this.time.delayedCall(120, () => {
                splash.setTexture('puddle');
                this.tweens.add({
                    targets: splash,
                    alpha: 0,
                    duration: 1000,
                    delay: 500,
                    onComplete: () => splash.destroy()
                });
            });
        });
    }

    playRandomSound(key, volume = 1) {
        let soundKey = key;
        
        if (key === 'sfx_hit') {
            const variation = Phaser.Math.Between(1, 3);
            soundKey = key + variation;
        }
        
        if (this.sound.get(soundKey)) {
             let detune = Phaser.Math.Between(-200, 200); 
             this.sound.play(soundKey, { detune: detune, volume: volume });
        }
    }
    
    movePlayer(kid, x, y) {
        x = Phaser.Math.Clamp(x, 40, 260); 
        y = Phaser.Math.Clamp(y, 70, 300);

        this.createSnowSplash(x, y); 
        this.playRandomSound('sfx_step', 0.2); 

        this.tweens.add({
            targets: kid,
            x: x,
            y: y,
            duration: Phaser.Math.Distance.Between(kid.x, kid.y, x, y) * 5,
            onStart: () => { if(kid.bodySprite.anims.exists('red_walk')) kid.bodySprite.play('red_walk'); },
            onComplete: () => { if(kid.isAlive) kid.bodySprite.play('red_idle'); }
        });
    }

    getClosestActive(team, pointer, maxDist = 1000) {
        // Match original: check if click is within player bounding box
        // Only allow selection of alive players who aren't walking onto field
        let clicked = null;
        team.forEach(kid => {
            if (!kid.isAlive) return;
            if (kid.isWalkingOntoField) return; // Can't select players still walking onto field
            // Use bounding box detection like original game
            // Original uses top-left origin, Phaser container is centered
            // Player sprite is roughly 30x35, use slightly larger hitbox for better UX
            let width = 35;
            let height = 45;
            // Offset to account for sprite alignment in container
            let hitX = kid.x - width / 2;
            let hitY = kid.y - height / 2;
            if (pointer.x >= hitX &&
                pointer.x <= hitX + width &&
                pointer.y >= hitY &&
                pointer.y <= hitY + height) {
                clicked = kid;
            }
        });
        return clicked;
    }

    // Show selection circle when hovering over player
    showSelectionUI(player) {
        // Draw selection circle (solid ellipse for ground perspective)
        this.selectionCircle.clear();
        this.selectionCircle.lineStyle(2, 0x0088cc, 1);
        this.selectionCircle.strokeEllipse(0, 0, 60, 30);
        this.selectionCircle.setPosition(player.x, player.y + 15);
        this.selectionCircle.setVisible(true);
    }
    
    // Show power meter when mousedown on player
    showPowerMeter(player) {
        this.powerMeterContainer.setPosition(player.x + 25, player.y + 20);
        this.powerMeterContainer.setVisible(true);
        this.updatePowerMeter();
    }
    
    // Update selection UI position to follow player
    updateSelectionUI(player) {
        if (!player) return;
        this.selectionCircle.setPosition(player.x, player.y + 15);
        if (this.powerMeterContainer.visible) {
            this.powerMeterContainer.setPosition(player.x + 25, player.y + 20);
        }
    }
    
    // Hide selection circle (when mouse leaves player)
    hideSelectionUI() {
        this.selectionCircle.setVisible(false);
        this.powerMeterContainer.setVisible(false);
    }
    
    // Hide power meter only (selection circle stays)
    hidePowerMeter() {
        this.powerMeterContainer.setVisible(false);
    }
    
    // Update power meter bars based on current strength
    updatePowerMeter() {
        const barsToShow = Math.ceil((this.activeStrength / this.maxStrength) * this.powerMeterBars.length);
        this.powerMeterBars.forEach((bar, index) => {
            bar.setVisible(index < barsToShow);
        });
    }
    
    // Draw a dashed ellipse (orthogonal/ground perspective)
    drawDashedEllipse(graphics, x, y, radiusX, radiusY, numDashes, gapAngle) {
        const totalAngle = 2 * Math.PI;
        const segmentAngle = totalAngle / numDashes;
        const dashAngle = segmentAngle * 0.7; // 70% dash, 30% gap
        
        for (let i = 0; i < numDashes; i++) {
            const startAngle = i * segmentAngle;
            const endAngle = startAngle + dashAngle;
            
            // Draw ellipse arc segment using individual line segments
            const steps = 12;
            let firstPoint = true;
            for (let j = 0; j <= steps; j++) {
                const angle = startAngle + (endAngle - startAngle) * (j / steps);
                const px = x + radiusX * Math.cos(angle);
                const py = y + radiusY * Math.sin(angle);
                
                if (j < steps) {
                    const nextAngle = startAngle + (endAngle - startAngle) * ((j + 1) / steps);
                    const nx = x + radiusX * Math.cos(nextAngle);
                    const ny = y + radiusY * Math.sin(nextAngle);
                    graphics.lineBetween(px, py, nx, ny);
                }
            }
        }
    }
}

const config = {
    type: Phaser.AUTO,
    width: 600,
    height: 320,
    parent: 'game-container',
    backgroundColor: '#ffffff',
    physics: { default: 'arcade' },
    scene: MainScene
};

const game = new Phaser.Game(config);
</script>
</body>
</html>